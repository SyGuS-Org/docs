\pdfoutput=1

%% LyX 2.1.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage{xspace}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{comment}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{The SyGuS Language Standard Version 2.0}


\author{Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle
\input{macros.tex}

\input{sygus-macros.tex}

\section{Introduction}
\label{sec:Introduction}
\input{introduction}

%\ajr{Intro to sygus and example}

\paragraph{Overview of This Document}

This document defines the SyGuS input language version 2.0,
which is intended to be used as the standard input and output languages
for SyGuS solvers and users of them.
The language borrows many concepts and language constructs
from the standard format for Satisfiability Modulo Theories (SMT)
solvers, the SMT-LIB language (version 2.6)~\cite{BarFT-RR-17}.

In the remainder of this section, we cover differences of
the language described in this document with previous revisions of the
SyGuS input language~\cite{sygusFormat} and cover the necessary preliminaries.
Then,
Section~\ref{sec:syntax}
gives the concrete syntax for commands in the SyGuS input language.
Section~\ref{sec:semantics}
documents the well-formedness and the semantics of input commands.
Section~\ref{sec:output}
documents the expected output of synthesis solvers in response to these commands.
Section~\ref{sec:sygus-logic}
describes formally the notion of a \emph{SyGuS logic} and how it restricts
the set of commands that are allowed in an input.
Section~\ref{sec:logical-semantics}
formalizes what consistutes a correct response to a SyGuS input.
Finally, Section~\ref{sec:examples}
provides examples of possible inputs in the SyGuS language
and solvers responses to them.

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
SyGuS standard document~\cite{sygusFormat},
and the extensions described in~\cite{sygusSyntax2015,sygusSyntax2016}.

\begin{enumerate}

\item The syntax for providing grammars inside the $\synthfunkwd$ command
now requires that non-terminal symbols are declared upfront
in a \emph{predeclaration}, see Section~\ref{ssec:dec-synth-fun}
for details.
%\rem{Mention Start symbol change if applicable.}

\item 
The keyword ${\tt Start}$, which 
denoted the starting (non-terminal) symbol of
grammars in this previous standard, has been removed.
Instead, the first symbol listed in the grammar is assumed
to be the starting symbol.

\item 
Terms that occur as the right hand side of production rules in
SyGuS grammars are now required to be binder-free.
In particular, this means that let-terms are now disallowed within grammars.
Accordingly,
the keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed since the former is equivalent to $\varkwd$
and the latter has no affect on the grammar.

\item The datatype keyword $\enumkwd$
and related syntactic features have been removed.
The standard SMT-LIB version 2.6 commands
for declaring datatypes are now adopted,
see Section~\ref{ssec:declaring-sorts} for details.

\item The $\setoptskwd$ has been renamed $\setoptkwd$ to 
correlate to the existing SMT-LIB version 2.6 command.

\item 
The syntax for terms and sorts
is now coincides with the corresponding syntax for terms and sorts 
from SMT-LIB versions 2.0 and later.
There are three notable changes
with respect to the previous SyGuS format that come as a result of this change.
First,
negative integer and real constants must be written with
unary negation, that is, the integer constant negative one
must be written ${\tt (-\ 1)}$, whereas previously it could
be written ${\tt -1}$.
Second,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Third,
all let-bindings do \emph{not} annotate the type of the variable being bound.
Previously, a let-term was written ${\tt (let\ ((x\ t\ T)) ...)}$
where ${\tt T}$ indicates the type of ${\tt t}$.
Now, it must be written in the SMT-LIB compliant
way ${\tt (let\ ((x\ t)) ...)}$.

\item
The signature, syntax and semantics for the theory of strings 
is now the one given in an initial proposal to SMT-LIB~\cite{smtlibStrings}.
Thus, certain new symbols are now present in the signature,
and some existing ones have changed names.
For example,
the conversion functions between strings and their integer representations
${\tt str.to.int}$ and ${\tt int.to.str}$ have been renamed
${\tt str.to}$-${\tt int}$ and ${\tt str.from}$-${\tt int}$.
The semantics of all operators,
which was not specified previously,
is now the one given by~\cite{smtlibStrings}.

%Furthermore, wherever applicable,
%the syntax for sorts and terms
%from other SMT theories assumes the syntax
%prescribed in theory definitions from SMT-LIB~\cite{}.

\item The command $\primedvardeclkwd$, which was syntax
sugar for two $\vardeclkwd$ commands in the previous standard, has been removed
for the sake of simplicity.
This command did not provide any benefit to
invariant synthesis problems, since constraints declared via $\constraintinvkwd$
do not accept global variables.
%\rem{TODO: This command is not used properly in current
%invariant synthesis benchmarks (since variables cannot be passed
%to inv-constraint commands), and only contributes
%to confusion, in my opinion. Ok to remove?
%}

%\item Change (fail)?

%\item Elaborations on the well-formedness of all commands.

\item 
The command $\fundeclkwd$,
which declared a universal variable of function type
in the previous standard,
has been removed.
%Solvers that wish to support synthesis conjectures
%with higher-order quantification

\item
A formal notion of input logics, output logics, and 
\emph{features} have been defined as part of the background logic,
and the command $\setfeaturekwd$ %and $\setfeaturesetkwd$
has been added to the language,
which is used for further refining restrictions or extensions
regarding the constraints, grammars and commands that may appear in an input.

\end{enumerate}


\subsection{Preliminaries}
In this document, we assume basic standard notions of
multi-sorted first-order logic.
We assume the reader is familiar
with sorts, well-sorted terms, (quantified) formulas
and free variables\footnote{
The definition of each of these coincides with
the definition given in the SMT-LIB standarard~\cite{BarFT-RR-17}.
}
If $e$ is a term or formula,
then we write $e[x]$ to denote that $x$ occurs free in $e$,
and $e[t]$ to denote the result of replacing all occurrences of $x$ by $t$.
We write $\lambda \vec{x}.\, t[\vec{x}]$ to denote a \emph{lambda term},
that is, an anonymous function whose argument list is $\vec{x}$
that returns the value of $t[\vec{s}]$ for all inputs $\vec{x} = \vec{s}$.
Given an application of a lambda term to a concrete argument list $\vec{s}$,
i.e. the term $(\lambda \vec{x}.\, t[\vec{x}])( \vec{s} )$,
then its \emph{beta-reduction} is the term $t[\vec{s}]$.
%In this document, we consider only \emph{simple} lambda terms 
%whose body itself contains no lambda terms.

\section{Syntax}
\label{sec:syntax}

In this section, we describe the concrete syntax
of SyGuS version 2.0 inputs.
This syntax borrows many definitions
from the SMT-LIB version 2.6 format~\cite{BarFT-RR-17}.
In the following description,
italic text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]
The syntax for commands $\cmd$ is given at the end of this section.
We first introduce the necessary preliminary definitions.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a semicolon, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters,
typically used to denote values or constant terms.
The SyGuS format includes syntax for several kinds of literals, listed below.
This treatment of most of these literals coincides with
those in the SMT-LIB version 2.6 format.
For full details, see Section 3.1 of~\cite{BarFT-RR-17}.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\end{array}
\end{alignat*}

\paragraph{Numerals ($\intconst$)}
Numerals are
either the digit $0$,
or a non-empty sequence of digits $\left[{\tt 0}-{\tt 9}\right]$
that does not begin with $0$.

\paragraph{Decimals ($\realconst$)}
The syntax for decimal numbers is $\intconst{\tt .\kstar{0}}\intconst$.

\paragraph{Booleans ($\boolconst$)}
Symbols $\truekwd$ and $\falsekwd$ denote the Booleans true and false.

\paragraph{Hexidecimals ($\hexconst$)}
Hexidecimals are written with ${\tt \#x}$
followed by a non-empty sequence of (case-insensitive) 
digits and letters taken from the ranges $\left[{\tt A}-{\tt F}\right]$
and $\left[{\tt 0}-{\tt 9}\right]$.

\paragraph{Binaries ($\binaryconst$)}
Binaries are written with ${\tt \#b}$
followed by a non-empty sequence of bits $\left[{\tt 0}-{\tt 1}\right]$.

\paragraph{Strings ($\stringconst$)}
A string literal $\stringconst$
is any sequence of printable characters
delimited by double quotes $\texttt{"}$ $\texttt{"}$.
The characters within these delimiters
are interpreted as denoting characters of the string in a one-to-one correspondence,
with one exception:
two consecutive double quotes within a string
denote a single double quotes character.
In other words, $\texttt{"}{\tt a}\texttt{"}\texttt{"}{\tt b}\texttt{"}$ denotes the string
whose characters in order are ${\tt a}$, $\texttt{"}$ and ${\tt b}$.
Strings such as $\texttt{"}{\tt \backslash n}\texttt{"}$ whose characters are commonly
interpreted as escape sequences are not handled specially,
meaning this string is interpreted 
as the one consisting of two characters, ${\tt \backslash}$ followed by ${\tt n}$.
%\rem{TODO: double quotes within strings escape, no other escape}

\ 

\noindent
Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses numerals to denote non-negative integer values.
The theory of bit-vectors uses both
hexadecimal and binary constants in the above syntax
to denote bit-vector values.
%For more details on common theories,
%see Section~\ref{ssec:smt-logic}.

\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see Appendix~\ref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with
symbols in Section 3.1 of the SMT-LIB version 2.6 format,
apart from differences in their reserved words.

\subsection{Identifiers}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes symbols that are indexed by integer constants or other symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of the SMT-LIB version 2.6 format.

\subsection{Sorts}

We work in a multi-sorted logic where terms 
are associated with sorts $\sortexpr$.
Sorts are constructed via the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
\sortexpr & ::= & \identifier\mbox{ }|\mbox{ }\paren{\identifier\mbox{ }\kplus{\sortexpr}}\\
\end{array}
\end{alignat*}
The \emph{arity} of the sort is the number of (sort) arguments it takes.
A \emph{parametric} sort is one whose arity is greater than zero.
Theories associate identifiers with sorts and sort constructors
that have an intended semantics.
Sorts may be defined by theories (see examples in Section~\ref{ssec:smt-logic})
or may be user-defined
(see Section~\ref{ssec:declaring-sorts}).

\subsection{Terms}

We use terms $\term$ to specify grammars and constraints,
which are constructed by the following syntax.
% ajr: version including qualified identifiers (perhaps too verbose)
\begin{comment}
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \qualidentifier & ::= & \identifier\mbox{ }|\mbox{ }\paren{\askwd\mbox{ }\identifier\mbox{ }\sortexpr}\\
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Above,
we distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain bound (local) variables.
Identifiers that comprise terms
may be \emph{qualified} with a type-cast, using the keyword $\askwd$.
Type casts are used for symbols whose type is ambiguous,
such as parametric datatype constructors, e.g. the nil constructor
for a parametric list.

Like sorts, the identifiers that comprise terms
can either be defined by the user or by background theories.
Examples of the latter are given in Section~\ref{ssec:smt-logic}.
\end{comment}
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \identifier\\
 & | & \literal\\
 & | & \paren{\identifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \identifier\\
 & | & \literal\\
 & | & \paren{\identifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Above,
we distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain bound (local) variables.
Like sorts, the identifiers that comprise terms
can either be defined by the user or by background theories.
%Examples of the latter are given in Section~\ref{ssec:smt-logic}.

\subsection{Features}
\label{ssec:syntax-features}

A feature $\feature$ denotes a restriction or extension
on the kinds of SyGuS commands that are allowed in an input.
It is an enumeration in the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
 \feature & ::= & \fgrammarskwd\mbox{ }|\mbox{ }\ffwddeclskwd\mbox{ }|\mbox{ }\frecursionkwd\mbox{ }
 % ajr: not needed
 %|\mbox{ }\fquantifierskwd
\end{array}
\end{alignat*}
More details on features are given in Section~\ref{sec:sygus-logic}.

\subsection{Commands}

A command $\cmd$ is given by the following syntax.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\checksynthkwd} \\
 & | & \paren{\constraintkwd\mbox{ }\term} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setfeaturekwd\mbox{ }:\feature\mbox{ }\boolconst} \\
% & | & \paren{\setfeaturesetkwd\mbox{ }\symbol} \\
% & | & \paren{\setlogicinputkwd\mbox{ }\symbol} \\
% & | & \paren{\setlogicoutputkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 % ajr: removed
 %\paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= &\paren{\dtdeclkwd\mbox{ }\symbol\mbox{ }\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }:\symbol\mbox{ }\literal} \\[2ex]
 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 %\sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\  %ajr: used above
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\sortexpr\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\paren{\varkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\bfterm\\
\end{array}
\]
For convenience,
we distinguish between two kinds of commands above.
The commands listed under $\cmd$ are specific to the SyGuS version 2.0 standard.
The remaining commands listed under $\smtcmd$
are borrowed from the SMT-LIB version 2.6 standard.
Details on the semantics of these commands are given in Section~\ref{sec:semantics}.

%\paragraph{Reserved Words}
%All strings mentioned in Section~\ref{ssec:literals}

\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands,
which at a high level
are used for defining a (single) synthesis conjecture
and invoking a solver for this conjecture.
This conjecture is of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall x_1,\ldots,x_m.\,(\varphi_1 \wedge \ldots \wedge \varphi_p )[f_1,\ldots,f_n,x_1,\ldots,x_m]
\end{alignat*}
In this section, we define how this conjecture is
is established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 
Given a sequence of commands, the current state consists of the following
information:
\begin{itemize}
\item A list
$f_1, \ldots, f_n$, which we refer to
as the current list of \emph{functions to synthesize},
\item A list 
$x_1, \ldots, x_m$ of variables, 
which we refer to the current list of \emph{universal variables}, 
\item A list of formulas
$\varphi_1, \ldots, \varphi_p$,
which we refer to as the current list of \emph{constraints},
\item A \emph{signature}
denoting the set of defined symbols in the current scope.
A signature is 
a mapping from symbols to expressions (either sorts or terms).
Each of these symbols may have a predefined semantics
either given by the theory,
or defined by the user (e.g. symbols that are defined as macros
fit the latter category).
\item A \emph{SyGuS logic} denoting the
terms and sorts that may appear in constraints and grammars.
\end{itemize}
In the initial state of a SyGuS input,
the lists of functions-to-synthesize, 
universal variables, constraints, and the signature are empty,
and the SyGuS logic is the default one 
(for details on the default SyGuS logic, see Section~\ref{sec:sygus-logic}).
%that is, 
%no restrictions are placed on the set of terms that may appear 
%in constraints and grammars.

In the following, we first describe restrictions
on the order in which commands can be specified in SyGuS inputs.
We then describe how each command $\cmd$ updates
the state of the sets above and the current signature.

\subsection{Command Ordering}
A SyGuS input is not well-formed
if it specifies a list of commands that do not meet
the restrictions given in this section regarding their order.

\rem{(Set logic | set extension | set option )* ( everything else )* ( check-synth )? }
%\rem{Order of commands}

\subsection{Setting the Logic}
\label{ssec:set-logic}

The logic of SyGuS consists of three parts,
an \emph{input logic}, an \emph{output logic} and a \emph{feature set}.
Roughly, 
the input logic determines what terms
can appear in constraints and
the output logic determines
what terms can appear in grammars and solutions.
The feature set places additional restrictions or extensions 
on the terms, grammars and commands that are allowed in an input.
These are described in detail in Section~\ref{sec:sygus-logic}.

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }S}$

This sets the SyGuS background logic
to the one that $S$ refers to.
The logic $S$ can be a standard one defined in SMT-LIB~\cite{BarFT-RR-17}
or may be solver-specific.
If $S$ is an SMT-LIB standard logic,
then the logic must 
contain quantifiers or this command is not well-formed,
that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.\footnote{
By convention quantifiers are always included in the logic. This is because
the overall synthesis conjecture specified by the
state may involve universal quantification.
}
If this command is well-formed and $S$ is an SMT-LIB standard logic,
then this command sets the SyGuS logic to the one whose
input and output logics are ${\tt QF\_}S$ and whose feature
set is the default one defined in this document (Section~\ref{ssec:feature-sets}).
In other words, when this command has $S$ as an argument
and $S$ is an SMT-LIB standard logic, this
indicates that that terms in the logic of $S$ are 
allowed in constraints, grammars and solutions, but they are
are restricted to be quantifier-free.
As a consequence, 
the overall synthesis conjectures 
allowed by default when $S$ is a standard SMT-LIB logic
%by symbols $S$ that correspond to SMT-LIB standard logics
have at most two levels of quantifier alternation.
%For examples of common SMT logics, 
%see Section~\ref{ssec:smt-logic}.
%If $S$ is a standard SMT-LIB logic,
%then this command adds the set of sort and function symbols
%from that logic to the current signature.
%In this case,
%the logic must contain quantifiers or this command is not well-formed,
%that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.
%In SyGuS, notice that the logic gives
%restrictions on both the kinds of terms that
%may appear in constraints, and may appear in grammars.
%We give details on the default settings of the logic for SyGuS inputs
%in Section~\ref{sec:sygus-logic}.
%In other words, the input logic is set to the quantifier-free
%version of the logic $S$ indicating that arbitrary quantified formulas
%cannot appear in constraints, and
%the output logic is set to $S$ itself.

\begin{comment}
\item $\paren{\setlogicinputkwd\mbox{ }S}$

This sets the input logic component of the SyGuS background logic
to the one $S$ refers to,
which can be a standard one defined in SMT-LIB~\cite{BarFT-RR-17}
or may be solver-specific.
%The logic must contain quantifiers or this command is not well-formed,\mbox{ }\tau_n
%that is, logics from the SMT-LIB standard 
%with the prefix ``${\tt QF\_}$'' are not allowed.
This command adds the set of sort and function symbols
from the logic to the current signature.
Some of the standard logics defined by SMT-LIB that can be an argument of this
command are given in Section~\ref{ssec:smt-logic}.

\item $\paren{\setlogicoutputkwd\mbox{ }S}$

This sets the output logic component of the SyGuS background logic
to the one $S$ refers to.
This command imposes the same restrictions on logics
as the previous command, and adds the set of sort and function symbols
from the logic to the current signature.

\item $\paren{\setfeaturesetkwd\mbox{ }S}$

This sets the feature set component of the SyGuS background logic
to the one specified by symbol $S$.
We do not standardize any examples of feature sets
in this document.
We remark that a feature set may correspond to a class of synthesis problems,
for example, synthesis conjectures having
a single non-recursive function-to-synthesize.
%Setting a feature set is syntactic sugar
%for the appropriate sequence of $\setfeaturekwd$ commands.
\end{comment}

\item $\paren{\setfeaturekwd\mbox{ }:F\mbox{ }b}$

This enables the feature specified by $F$
in the feature set component of the SyGuS background logic
if $b$ is $\truekwd$, or disables it if $b$ is $\falsekwd$.
%This may affect the set of commands 
%allowed in an input,
%or further refinements to the restrictions placed
%on the set of allowed constraints and grammars.
All features standardized by this document 
are given in Section~\ref{ssec:feature-sets}.

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }S\mbox{ }\sigma}$

This command appends $S$ to the current list of universal variables
and adds the symbol $S$ of sort $\sigma$ to the current signature.
This command should be rejected if $S$ is already
a symbol in the current signature.

%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

%\item $\paren{\fundeclkwd\mbox{ }S\mbox{ }\paren{\sigma_1 \ldots \sigma_n}\mbox{ }\sigma}$

%This command adds $S$ to the current set of universal variables.
%The sort of $S$ is $\sigma$ if $n=0$ or
%$\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$ if $n>0$.
%This command should be rejected if $S$ is already
%a symbol in the current signature.

%\rem{This is higher-order quantification.
%TODO: rename this ``declare-var-fun''? Parallel with declare-const -> declare-var.
%Maybe remove this command.
%}

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}
\label{ssec:dec-synth-fun}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
\koption{G}}$

This command adds $S$ to the current list of functions to synthesize,
and adds the symbol $S$ of 
sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$
to the current signature.
This command should be rejected if $S$ is already
a symbol in the current signature.
We describe restrictions and well-formedness requirements for this command
in the following.

If provided, the syntax for the grammar $G$
consists of two parts: 
a \emph{predeclaration}
$\paren{\paren{y_1\mbox{ }\tau_1} \ldots \paren{y_n\mbox{ }\tau_n}}$,
followed by a \emph{grouped rule listing}
$\paren{\paren{y_1\mbox{ }\tau_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots \paren{y_n\mbox{ }\tau_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}$
where $y_1, \ldots, y_n$ are the \emph{non-terminal} symbols of the grammar.
Note that the same variable symbols
$y_1, \ldots, y_n$ and their sorts 
$\tau_1, \ldots, \tau_n$ appear both in the predeclaration and as heads
of each of the rules.
If this is not the case, then this command is not well-formed.
For all $i,j$, recall that grammar term $g_{ij}$ is either a term, or a class of terms
denoted by $\paren{\constantkwd\mbox{ }\sigma_c}$ 
and $\paren{\varkwd\mbox{ }\sigma_v}$ denoting respectively
the set of constants whose sort is $\sigma_c$,
and the set of all variables from $x_1, \ldots, x_n$ whose sort is $\sigma_v$.
If $g_{ij}$ is an ordinary term, then its free variables may contain $y_1, \ldots, y_n$,
as well as $S$ itself.
If the grammar contains $S$ itself, then it is possible that the definition
given for $S$ in a solution is recursive, however,
this feature is disallowed in the default logic (see Section~\ref{sec:sygus-logic}).

This command is not well-formed if
$\tau_1$ (the type of the start symbol) is not $\sigma$.
%\rem{TODO: should we make the first symbol of list the start symbol, instead of distinguished Start keyword?},
It is also not well-formed if
$G$ generates a term $t$ from $y_i$
that does not have type $\tau_i$ for some $i$.

If provided, the grammar $G$ must also be one that is allowed
by the output logic of the current SyGuS logic.
For more details on the restrictions imposed on grammars by the logic,
see Section~\ref{sec:sygus-logic}.
If $G$ does not meet the restrictions
of the background logic, it should be rejected.

If no grammar is provided,
then any term of the appropriate sort
in the output logic may be given in the body of a solution for $S$.

More details on grammars and the terms
they generate, as well as what denotes a term that meets the syntactic
restrictions of a function-to-synthesize
is discussed in detail in Section~\ref{ssec:sat-syntactic}.

\begin{comment}
If $G$ is not provided,
then this command is syntax
sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
G_{\mathcal{L},\vec{x},\sigma}}$
where $G_{\mathcal{L},\vec{x},\sigma}$ is a grammar that
generates all well-sorted terms of sort $\sigma$ 
that belong to the language of the current background logic $\mathcal{L}$,
and whose free variables are in $\vec{x} = (x_1, \ldots, x_n)$.
%We call $G_{\mathcal{L},\sigma,\vec{x}}$ the \emph{default}
%grammar for $(T,\sigma,\vec{x})$.
\end{comment}

\item $\paren{\synthinvkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\koption{G}}$

This is syntax sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\boolkwd\mbox{ }\koption{G}}$.
\end{itemize}

\subsection{Declaring Sorts}
\label{ssec:declaring-sorts}

In certain logics, 
it is possible for the user to declare user-defined sorts.
For example, 
$\dtsdeclkwd$ commands may be given
when the theory of datatypes is enabled in the background
logic,
$\sortdeclkwd$ commands may be given
when uninterpreted sorts are enabled in the background logic.

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }S\mbox{ }D}$

This is syntax sugar for
$\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S\mbox{ }0} }\mbox{ }\paren{D}}$.

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S_1\mbox{ }a_1}\ldots\paren{S_n\mbox{ }a_n} }\mbox{ }\paren{D_1 \ldots D_n}}$

This command adds symbols corresponding to the datatype
definitions $D_1, \ldots, D_n$ for $S_1, \ldots, S_n$ 
to the current signature.
For each $i = 1, \ldots, n$, integer constant $a_i$ denotes the arity of 
datatype $S_i$.
The syntax of 
$D_i$ is a \emph{constructor listing} of the form
\[
\paren{
\paren{c_1\mbox{ }\paren{s_{11}\mbox{ }\sigma_{11}}\mbox{ }\ldots\mbox{ }\paren{s_{1m_1}\mbox{ }\sigma_{1m_1}} }
\mbox{ }\ldots\mbox{ }
\paren{c_k\mbox{ }\paren{s_{k1}\mbox{ }\sigma_{k1}}\mbox{ }\ldots\mbox{ }\paren{s_{km_k}\mbox{ }\sigma_{km_k}} }
}
\]
For each $i$, the following symbols are added to the signature:
\begin{enumerate}
\item 
Symbol $S_i$ is added to the current signature,
defined it as a datatype sort whose definition is given by $D_i$,
\item 
Symbols $c_1, \ldots, c_k$ are added to the signature,
where
for each $j = 1, \ldots, k$, symbol $c_j$
is defined as a \emph{constructor}
of sort $\sigma_{j1} \times \ldots \times \sigma_{jm_j} \rightarrow D_i$,
\item 
For each $j = 1, \ldots, k$, $\ell = 1, \ldots m_j$, symbol $s_{j\ell}$
is added to the signature,
defined as a \emph{selector}
of sort $D_i \rightarrow \sigma_{j\ell}$.
%For each $j = 1, \ldots, k$, 
\end{enumerate}

%\rem{Explain symbols?}
This command should be rejected if any of the above symbols this command
adds to the signature are already
a symbol in the current signature.
We provide examples of datatype definitions in Section~\ref{sec:examples}.
For full details on well-formed datatype declarations,
refer to Section 4.2.3 of the SMT-LIB version 2.6~\cite{BarFT-RR-17}.

\item $\paren{\sortdeclkwd\mbox{ }S\mbox{ }n}$

This command adds the symbol $S$ to the current signature
and associates it with an uninterpreted sort of arity $n$.
This command should be rejected if $S$ is already
a symbol in the current signature.

\end{itemize}

\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }\sigma\mbox{ }t}$

This adds to the current signature
the symbol $S$ of sort $\sigma$
if $n=0$ or $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$ if $n>0$.
The variables $x_1, \ldots, x_n$ may occur freely in $t$.
It defines $S$ as a term whose semantics are given by the function
$\lambda x_1, \ldots, x_n.\, t$.
Notice that $t$ may not contain any free occurrences of $S$,
that is, the definition above is not recursive.
This command is not well-formed if $t$ is not a well-sorted
term of sort $\sigma$.
This command should be rejected if $S$ is already
a symbol in the current signature.

\item $\paren{\sortdefkwd\mbox{ }S\mbox{ }\paren{u_1 \ldots u_n}\mbox{ }\sigma}$

This adds the symbol $S$ to the current signature.
It defines $S$ as the sort $\sigma$.
The sort variables $u_1, \ldots, u_n$
may occur free in $\sigma$,
while $S$ may not occur free in $\sigma$.
This command is not well-formed if $\sigma$
is not a well-formed sort.
This command should be rejected if $S$ is already
a symbol in the current signature.

\end{itemize}

\subsection{Asserting Synthesis Constraints}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }t}$

This adds $t$ to the set of constraints.
This command is well formed if $t$ is a well-sorted formula,
that is, a well-sorted term of sort $\sbool$.
% constraint
%We further require that $t$ is in the logic of
Furthermore,
the term $t$ should be allowed
based on the restrictions of the current logic,
see Section~\ref{sec:sygus-logic} for more details.

\item $\paren{\constraintinvkwd\mbox{ }S\mbox{ }S_{pre}\mbox{ }S_{trans}\mbox{ }S_{post}}$

%This command is syntax-sugar for
%declaring a set of variables 
%and asserting a constraint corresponding to the invariant synthesis problem.
This command adds a set of constraints to the current 
state that correspond to an invariant synthesis problem for function-to-synthesize $S$,
where $S_{pre}$ denotes a pre-condition,
$S_{post}$ denotes a post-condition
and $S_{trans}$ denotes a transition relation.

A constraint of this form is well-formed if:
\begin{enumerate}
\item
$S$ is the function-to-synthesize
of sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sbool$,
\item
$S_{pre}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{pre}$,
\item
$S_{trans}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n, y_1, \ldots, y_n.\, \varphi_{trans}$, and
\item
$S_{post}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{post}$.
\end{enumerate}
where $(x_1, \ldots, x_n)$ and $(y_1, \ldots, y_n)$
are tuples of variables of sort $(\sigma_1, \ldots, \sigma_n)$ and
$\varphi_{pre}$, $\varphi_{trans}$ and $\varphi_{post}$ are formulas.
Given that this command is well-formed, given the above definitions,
this command is syntax sugar for:
\[
\begin{array}{l}
\paren{\vardeclkwd\mbox{ }v_1\mbox{ }\sigma_1}\\
\paren{\vardeclkwd\mbox{ }v'_1\mbox{ }\sigma_1}\\
\ldots\\
\paren{\vardeclkwd\mbox{ }v_n\mbox{ }\sigma_n}\\
\paren{\vardeclkwd\mbox{ }v'_n\mbox{ }\sigma_n}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S_{pre}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{{\tt and}\mbox{ }\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{trans}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}\mbox{ }
\paren{S\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{post}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\end{array}
\]
where $v_1, v'_1, \ldots, v_n, v'_n$ are fresh symbols.

\end{itemize}

\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$

This asks the synthesis solver to find a solution for the synthesis conjecture
corresponding to the current list of functions-to-synthesize,
universal variables and constraints.
The expected output from the synthesis solver is covered in Section~\ref{sec:output}.
\end{itemize}

\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }:S\mbox{ }L}$

This sets the solver-specific option specified by the symbol $S$ 
to the (literal) value $L$, whose syntax is given in Section~\ref{ssec:literals}.
We do not give concrete examples of such options in this document. %\rem{Any needed?}
It is recommended that synthesis solvers
ignore unrecognized options, 
and choose reasonable defaults when the
options are left unspecified.
\end{itemize}

\section{Synthesis Solver Output}
\label{sec:output}

This section covers the expected output from a synthesis solver,
which currently is limited to responses to $\checksynthkwd$ 
only.

\begin{itemize}
\item
A well-formed response to $\checksynthkwd$ is one of the following:

\begin{enumerate}
\item
A list of $\fundefkwd$ commands of the form:
\[
\begin{array}{l}
\paren{\fundefkwd\mbox{ }f_{1}\mbox{ }X_{1}\mbox{ }\sigma_{1}\mbox{ }t_{1}}\\
\ldots\\
\paren{\fundefkwd\mbox{ }f_{n}\mbox{ }X_{n}\mbox{ }\sigma_{n}\mbox{ }t_{n}}
\end{array}
\]
where functions $f_{1}, \ldots, f_{n}$
are the functions-to-synthesize in the current state,
%\rem{Probably should be in order declared, 
%or otherwise would have to enforce dependent definitions are ordered properly}, 
$X_{1}, \ldots, X_{n}$ are sorted variable lists,
$\sigma_{1}, \ldots, \sigma_{n}$ are types,
and $t_{1}, \ldots, t_{n}$ are terms.
It is required that $f_1, \ldots, f_n$ be
provided in the order in which they were declared.\footnote{
This is to ensure that the definition of $f_i$, which may depend on a definition
of $f_j$ for $j<i$, is given in the correct order.
}
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{j}$ is a term of $\sigma_{j}$,
and $X_{j}$ is identical to the sorted variable list
used when introducing the function-to-synthesize $f_{j}$.

\item
The output ${\tt (fail)}$.

\end{enumerate}

A response to $\checksynthkwd$ is a correct solution if
it satisfies both the semantic and syntactic restrictions given by
the current state.
We describe this in more detail in Section~\ref{sec:logical-semantics}.

We do not define the correctness of a ${\tt fail}$ response 
in this document. We remark that a fail response may be given
by a solver either when it is unable to find a solution for the current
synthesis conjecture, or if it has determined that a solution does not exist.

\end{itemize}

%\section{

\section{SyGuS Background Logics}
\label{sec:sygus-logic}

In this section,
we describe how the background logic
restricts the constraints and grammars that are allowed as inputs.
%As mentioned in Section~\ref{ssec:set-logic},
%a SyGuS input may be given a background logic
%specified by a symbol $S$,
%where $S$ may be a standard SMT-LIB logic
%or may be solver-specific.
%We refer to $S$ as the \emph{base logic}
%of a SyGuS input.
A SyGuS background logic consists of three parts:
\begin{enumerate}
\item An \emph{input logic}, which can be set as part of a $\setlogickwd$ command.
This corresponds to a SMT-LIB standard logic or may be solver specific.
The input logic determines the set of terms that are allowed in 
constraints.

\item An \emph{output logic}, which can be set as part of a $\setlogickwd$ command.
Like input logics, this
can correspond to an SMT-LIB standard logic or may be solver specific.
The output logic determines the set of terms that are allowed in
grammars and solutions.

\item A \emph{feature set}, 
which restricts or extends the set of commands that are allowed in a SyGuS input,
and may further refine the constraints, grammars and solutions allowed by the logic.
Generally, feature sets are not expressible in an input or output logic
and are independent of them.
\end{enumerate}
%We give more detail on what consistutes an extended logic in the following.

The default SyGuS logic is the one
whose the input and output logics include only the core theory of Booleans,
and whose feature set enables grammars and the core commands of the language.
We describe logics and feature sets
in more detail in
Sections~\ref{ssec:smt-logic} and~\ref{ssec:feature-sets}.
A formal definition of how these
restrict the set of terms that may appear 
in constraints and grammars
is then given in Sections~\ref{ssec:logicr-constraints} and~\ref{ssec:logicr-grammars}.
%We give three such examples in Section~\ref{ssec:logicr-grammars}
%below.
%\rem{Standard extension to base logic + extensions?}
%This section pertains only to 

\subsection{Input and Output Logics}
\label{ssec:smt-logic}

%This section covers only base logics defined in the SMT-LIB standard.
SMT-LIB provides a catalog of standard logics,
available at \url{www.smt-lib.org}.
SyGuS logics may use any of these logics
either as input logics or as output logics.
For many applications,
the input and output logic is expected to be the same, although
no relationship between the two is required.

At a high level, a \emph{logic} includes a set of theories
and defines a subset of terms constructible in the signature of those theories
that belong to it.
If a logic includes a theory, then its symbols are added
to the current signature when a $\setlogickwd$ command is issued.
Further details on the formal definition of 
theory and logic declarations can be found in Sections 3.7 and 3.8
of the SMT-LIB version 2.6 standard~\cite{BarFT-RR-17}.
We briefly review some of the important logics and theories in the following.
More concrete details on
standard SMT-LIB logics can be found in the reference
grammars in Appendix~\ref{apx:ref-grammars}.

The input and output logic components of the default SyGuS logic include only the
\emph{core theory}.
The signature of the core theory 
has the Boolean sort ${\tt Bool}$,
the Boolean constants ${\tt true}$ and ${\tt false}$, the
usual logical Boolean connectives 
${\tt not}$, ${\tt and}$, ${\tt or}$, implication ${\tt =>}$, ${\tt xor}$,
and the parametric symbols ${\tt =}$ and ${\tt ite}$
denoting equality and if-then-else terms for all sorts in the signature.
%that is, no restrictions are placed on the set of terms that may 
%appear, nor are any symbols predefined.
The logics mentioned in this section supplement the signature
of the current state with additional sorts and symbols.

\paragraph{Arithmetic}
The theory of integers is enabled 
in logics like linear integer arithmetic ${\tt LIA}$
or non-linear integer arithmetic ${\tt NIA}$.
The signature of this theory includes the integer sort ${\tt Int}$ and
typical function symbols of arithmetic, including
addition ${\tt +}$
and multiplication ${\tt *}$.
Unary negation and subtraction are specified by ${\tt -}$.
Constants of the theory are integer constants.
Positive integers and zero are specified by the syntax $\intconst$ from Section~\ref{ssec:literals},
whereas negative integers are specified as the unary negation of positive integer,
that is, ${\tt (-\ 2)}$ denotes negative two.
Analogously, 
the theory of reals is enabled
in logics like linear real arithmetic ${\tt LRA}$
or non-linear real arithmetic ${\tt NRA}$.
Its signature includes the real sort ${\tt Real}$.
Some of the function symbols of arithmetic are syntacticaly identical to
those from the theory of integers, including
${\tt +}$, ${\tt -}$ and ${\tt *}$.
The signature of the theory of reals additionally includes
real division ${\tt /}$.
Positive reals and zero in this theory can either be specified as
decimals using the syntax $\realconst$
or as rationals of the form ${\tt (/\ m\ n)}$,
where ${\tt m}$ and ${\tt n}$ are numerals.
Negative reals are specified as the unary negation of a decimal
or as a negative rational ${\tt (/\ (-\ m)\ n)}$.

\paragraph{Bit-Vectors}
The theory of fixed-width bit-vectors
is included in logics specified 
by symbols that include the substring ${\tt BV}$.
The signature of this theory includes a family of 
indexed sorts ${\tt (\_\ BitVec\ n)}$
denoting bit-vectors of width $n$.
The functions in this signature include various operations on bit-vectors,
including bit-wise, arithmetic, and shifting operations.

\paragraph{Strings}
The theory of (unbounded) unicode strings and regular expressions
is included in some logics specifed with ${\tt S}$ as a prefix,
such as ${\tt S}$ (strings) or ${\tt SLIA}$ (strings
with linear integer arithmetic).
The string of this theory includes the string sort ${\tt String}$,
interpreted as the set of all unicode strings.
Functions in this signature include string concatenation ${\tt str.++}$,
string length ${\tt str.len}$ as well as many extended functions
such as string containment ${\tt str.contains}$,
string index-of ${\tt str.indexof}$ which returns the index of
a string in another, and so on.
A full description of this theory is given by the proposal in~\cite{smtlibStrings}.

\paragraph{Arrays}
The theory of arrays is included in logics specifed with ${\tt A}$ as a prefix,
such as ${\tt ABV}$ or ${\tt ALIA}$.
The signature of this theory includes a parametric sort ${\tt Array}$
of arity two, whose sort parameters
indicate the index type and the element type of the array.
It has two function symbols, ${\tt select}$ and ${\tt store}$,
interpreted as array select and array store.

\paragraph{Datatypes}
The theory of datatypes
is included in logics specified 
by symbols that include the substring ${\tt DT}$.
Logics that include datatypes are such that
$\dtsdeclkwd$ commands are permitted in inputs, 
whereas all others do not.
The signature of the theory of datatypes
is largely determined by the concrete datatypes definitions provided
by the user.
As mentioned in Section~\ref{ssec:declaring-sorts}, these commands append datatype sorts, 
constructors and selectors to the current signature.
Constructor symbols are used for constructing
values (e.g. ${\tt cons}$ constructs a list from an element and another list),
and selectors access subfields (e.g. ${\tt tail}$ returns its second argument).
Notice that the value of \emph{wrongly applied} selectors, e.g. ${\tt tail}$ applied
to the nil list, is underspecified and hence freely interpreted
in models of this theory.
The only fixed symbol of the theory of datatypes is the unary
indexed \emph{discriminator} predicate ${\tt(\_\ is\ C)}$,
which holds if and only if its argument is an application of constructor $C$.
For example, assuming the standard definition of a list datatype
with constructors ${\tt cons}$ and ${\tt nil}$,
we have that ${\tt ((\_\ is\ nil)\ x)}$ holds if and only if
$x$ is the nil list.

\paragraph{Uninterpreted Functions}
In SMT-LIB, uninterpreted functions and sorts may be declared in
logics that include the substring ${\tt UF}$,
whose interpretations are not fixed.
Declarations for functions and sorts are made via SMT-LIB commands 
$\fundeclkwd$ and $\sortdeclkwd$ respectively.
In the SyGuS standard language, we do not permit
the declaration of functions with $\fundeclkwd$ command.
Instead, the language includes only the latter command.
Thus, the only effect that specifying ${\tt UF}$ in the logic string has is
that user-defined sorts may be declared via $\sortdeclkwd$, where
variables and functions-to-synthesize may involve these sorts in the usual way.
We remark here that
encoding synthesis problems 
that involve (existentially quantified)
uninterpreted functions
can be represented by declaring those functions
using $\synthfunkwd$ commands where no grammar is provided.
Synthesis problems that involve universally quantified variables of function sort
are planned to be addressed in a future revision of this document
that includes concrete syntax for function sorts.

\subsection{Features and Feature Sets}
\label{ssec:feature-sets}

A feature set is a set of values, called \emph{features},
which for the purposes of this document can be seen as an enumeration type.
Their syntax is given in Section~\ref{ssec:syntax-features}.
The meaning of all features standardized by this document are listed below.
\begin{itemize}
\item $\fgrammarskwd$: if enabled, 
then grammars may be provided for functions-to-synthesize 
in $\synthfunkwd$ commands.
\item $\ffwddeclskwd$: if enabled,
grammars of $\synthfunkwd$ may refer to previously declared synthesis functions,
called \emph{forward declarations}.
\item $\frecursionkwd$: if enabled,
grammars of $\synthfunkwd$ can generate terms that correspond to recursive definitions.
%\item $\fquantifierskwd$: if enabled,
%arbitrary quantification is allowed in constraints.
\end{itemize}
Formal definition of these features are given within the 
Sections~\ref{ssec:logicr-constraints} and~\ref{ssec:logicr-grammars}.
Other features and their meanings may be solver specific, 
which are not covered here.

The feature set component of the default SyGuS logic is the set $\{ \fgrammarskwd \}$.
In other words, grammars may be provided, but those involving
forward declarations and recursion are not permitted by default.

\subsection{SyGuS Logic Restrictions on Constraints}
\label{ssec:logicr-constraints}

%For the former,
%we follow the same conventions as SMT-LIB
%if $S$ is a standard SMT-LIB logic.
%For the latter,
%we give details on the default settings of the logic
%with respect to restrictions on terms that may appear in grammars
%in Section~\ref{sec:sygus-logic}.

%This section defines restrictions on the terms $t$
%that can appear in commands of the form $\paren{\constraintkwd\mbox{ }t}$.
Let $\slogic$ be a SyGuS logic whose input logic
is one from the SMT-LIB standard.
A term $t$ is not allowed by $\slogic$ 
to be an argument to a $\constraintkwd$ command 
if it is not allowed by the input logic of $\slogic$, 
according to the definition of that logic in the SMT-LIB standard.
%Exceptions to this rule are described here.

%By convention, as stated in Section~\ref{ssec:set-logic}, 
%the base logic specified
%by a $\setlogickwd$ in a SyGuS file must allow quantifiers.
%%This is due to the fact that
%%the synthesis conjecture implicit in the state
%%contains universal quantification on the universal variables of our state.
%However,
%constraints \emph{cannot} themselves contain 
%formulas with quantifiers
%unless the feature $\fquantifierskwd$ is enabled in the background logic.

%\rem{Reference extension?}

\subsection{SyGuS Logic Restrictions on Grammars}
\label{ssec:logicr-grammars}

%This section defines restrictions on the terms
%that may appear in grammars.
%The base logic affects the kinds of grammars that
%are allowed in SyGuS inputs.
Let $\slogic$ be a SyGuS logic whose output logic
is one from the SMT-LIB standard.
A grammar $G$ is not allowed by $\slogic$ if
it generates some term $t$ that 
has no free occurrences of non-terminal
symbols, and is not allowed by the output logic of $\slogic$.
%For instance, 
%this restriction disallows grammars
%in the logic of \emph{linear} integer arithmetic
%for which it is possible to generate a term involving
%the multiplication of two non-constant integer terms.

Notice that it may be the case that a grammar $G$
contains a rule whose conclusion does not itself meet the restrictions 
of the output logic.
For example, consider the logic of \emph{linear} integer arithmetic
and a grammar $G$ containing a non-terminal symbol $y_c$ of integer type
such that $G$ generates only constants from $y_c$.
Grammar $G$ may be allowed in the logic of linear integer arithmetic
even if it has a rule whose conclusion is $y_c * t$, 
noting that no non-linear terms can be generated from this rule,
provided that no non-linear terms can be generated from $t$.
An example of this form is given in Section~\ref{sec:examples}.
%then the term $y_c * y$ may be the conclusion
%grammar terms $g_{ij}$ may involve
%the multiplication of two non-constant integer terms $t_1$ and $t_2$
%e.g. in the case there one of $t_i$ is a non-terminal symbol $y$
%for which $G$ generates only constant integer terms from $y$.

%The default logic assumed by the SyGuS standard assumes
%additional restrictions on the terms that are generated by grammars.
The feature set component of the SyGuS logic 
may impose additional restrictions
on the terms that are generated by grammars.
Note the following definition.
The \emph{expanded form} of a term $t$
is the (unique) term obtained
by replacing all functions $f$ in $t$ that are defined as macros
%in the current signature
with their corresponding definition until a fixed point is reached.
A grammar $G$ for function-to-synthesize $f$ is not allowed by a SyGuS logic $\slogic$
if $G$  contains a rule whose conclusion is a term $t$
whose expanded form contains applications of functions-to-synthesize
unless the feature $\ffwddeclskwd$ is enabled in the feature set of $\slogic$;
it is not allowed if $t$ 
contains $f$ itself unless the feature $\frecursionkwd$ is enabled in the feature set of $\slogic$;
it is not allowed regardless of the terms it generates unless $\fgrammarskwd$ is enabled in the feature set of $\slogic$.

\rem{Special logics: PBE, single invariant synthesis?}

\section{Formal Semantics}
\label{sec:logical-semantics}

Here we give the formal semantics
for what constitutes a correct solution for a synthesis conjecture.

\subsection{Satisfying Syntactic Specifications}
\label{ssec:sat-syntactic}

In this section,
we formalize the notion of satisfying the \emph{syntactic specification}
of the synthesis conjecture.

As described in Section~\ref{ssec:dec-synth-fun},
a grammar $G$ is specified as
a \emph{grouped rule listing} of the form
\[
\paren{\paren{y_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots 
\paren{y_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}
\]
where $y_1, \ldots, y_n$ are variables
and $g_{11} \ldots g_{1m_1}, \ldots, g_{n1} \ldots g_{nm_n}$
are grammar terms.
We associate each grammar with a sorted variable list $X$,
namely the argument list of the function-to-synthesize.
We refer to $y_1$ as the \emph{start symbol} of $G$.

We interpret $G$ as a (possibly infinite) set of rules 
of the form $y \mapsto t$ where $t$ is an (ordinary) term
based on the following definition.
For each $y_i, g_{ik}$ in the grouped rule list,
if $g_{ik}$ is $\paren{\constantkwd\mbox{ }\sigma_c}$,
then $G$ contains the rule $y_i \mapsto c$ for all constants of sort $\sigma_c$.
If $g_{ik}$ is $\paren{\varkwd\mbox{ }\sigma_v}$,
then $G$ contains the rule $y_i \mapsto x$
for all variables $x \in X$ of sort $\sigma_v$.
Otherwise, if $g_{ik}$ is an ordinary term,
then $G$ contains the rule $y_i \mapsto g_{ik}$.

We say that $G$ \emph{generates} term $r$ from $s$
if it is possible to construct a sequence of terms
$s_1, \ldots, s_n$
with $s_1 = s$ and $s_n = r$
where for each $1 \leq i \leq n$, term $s_i$ is obtained from $s_{i-1}$ by
replacing an occurrence of some $y$ by $t$
where $y \mapsto t$ is a rule in $G$.

Let $f$ be a function to synthesize.
A term $\lambda X.\, t$
satisfies the syntactic specification for $f$
if one of the following hold:
\begin{enumerate}
\item 
A grammar $G$ is provided for $f$,
$t$ contains no free occurrences of non-terminal symbols,
and $G$ generates $t$ starting from $y_1$,
where $y_1$ is the start symbol of $G$.

\item
No grammar is provided for $f$, and $t$ is any
term allowed in the output logic whose sort
is the same as the return sort of $f$.
\end{enumerate}
%\rem{More}
%whose variable lists are $X_1, \ldots, X_n$
%and whose grammars are $G_1, \ldots, G_n$.

Furthermore,
A tuple of functions 
$( \lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n )$
satisfies the syntactic restrictions
for functions-to-synthesize $( f_1, \ldots, f_n )$
in conjecture $\exists f_1, \ldots, f_n.\, \varphi$
if $\lambda X_i.\, t_i$
satisfies the syntactic specification for $f_i$
for each $i=1,\ldots,n$.
%\end{def}

\subsection{Satisfying Semantic Specifications}
\label{ssec:sat-semantic}

In this section,
we formalize the notion of satisfying the \emph{semantic specification}
of the synthesis conjecture
for background theories $T$ from the SMT-LIB standard.
The notion of satisfying semantic restrictions for background theories
that are not standardized in the SMT-LIB standard are not covered by this document.

A tuple of functions 
$( \lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n)$
satisfies the semantic restrictions
for functions-to-synthesize $( f_1, \ldots, f_n )$
in conjecture $\exists f_1, \ldots, f_n.\,  \varphi$ in background theory $T$
if $\varphi$ is $T$-valid formula
when $f_1, \ldots, f_n$ are defined to be terms
whose semantics are given by the functions
$\lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n$.
%where $\psi$ is the formula
%$\varphi \{ f_1 \mapsto \lambda X_1.\, t_1, \ldots, f_n \mapsto \lambda X_n.\, t_n \}$
%after beta-reduction.
The formal definition for $T$-valid here
corresponds to the definition given by SMT-LIB,
for details see Section 5 of~\cite{BarFT-RR-17}.

The above definition covers cases where $f_1, \ldots, f_n$
have recursive definitions or references to forward declarations.
A formal description of $T$-valid formulas that contain these kinds of
functions assumes the semantics for SMT-LIB input formulas that involve
(defined) macros and recursive functions.

\section{Examples}
\label{sec:examples}

\rem{Simple LIA example}

\paragraph{Linear Arithmetic with Constant Coefficients}
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(synth-fun f ((x Int) (y Int)) Int
   ((I Int) (Ic List))
   ((I Int (0 1 x y
            (+ I I)
            (* Ic I)))
    (Ic Int (0 1 2 (- 1) (- 2)))))
(declare-var x Int)
(declare-var y Int)
(constraint (= (f x y) (* 2 (- x y))))
(check-synth)
\end{lstlisting}
In this example, the logic is set 
to linear integer arithmetic.
The grammar of the function-to-synthesize $f$
has two non-terminals, ${\tt I}$ and ${\tt Ic}$.
What is notable in this example is that
the grammar for $f$ includes a rule for ${\tt I}$ whose right hand side 
is the term ${\tt(*\ Ic\ I)}$. 
If a term of this form were to appear
in a constraint, 
then it would not be allowed since it is the
multiplication of two non-constant terms and thus is not allowed by the input logic ${\tt LIA}$.
However, 
by the definition of our restrictions on grammars in Section~\ref{ssec:logicr-grammars},
this grammar \emph{is allowed},
since all closed terms that the grammar generates (those that do not have
non-terminal symbols as free variables) are allowed by linear arithmetic.
A possible correct solution to this synthesis conjecture is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x Int) (y Int)) Int (+ (* 2 x) (* 2 y)))
\end{lstlisting}

\paragraph{Datatypes with Linear Arithmetic}

Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic DTLIA)
(declare-datatypes ((List 0)) ((nil) (cons (head Int) (tail (List Int)))))
(synth-fun f ((x List)) Int
   ((I Int) (L List) (B Bool))
   ((I Int (0 1 
            (head L) 
            (+ I I)
            (ite B I I)))
    (L List (nil x (cons I L) (tail L)))
    (B Bool (((_ is nil) L) 
             ((_ is cons) L)
             (= I I)
             (>= I I)))))
(constraint (= (f (cons 4 nil)) 5))
(constraint (= (f (cons 0 nil)) 1))
(constraint (= (f nil) 0))
(check-synth)
\end{lstlisting}
In this example, the logic is set to 
datatypes with linear integer arithmetic ${\tt DTLIA}$.
A datatype ${\tt List}$ is then declared,
which encodes lists of integers with two constructors ${\tt nil}$ and ${\tt cons}$.
The input contains a single-function to synthesize $f$
that takes as input a list and returns an integer.
Its grammar contains non-terminal symbols for integers, lists and Booleans,
and includes applications of constructors ${\tt nil}$ and ${\tt cons}$,
selectors ${\tt head}$ and ${\tt tail}$, and
discriminators ${\tt (\_\ is\ nil)}$ and ${\tt (\_\ is\ cons)}$.
A possible correct solution to this synthesis conjecture is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x List)) Int (ite ((_ is nil) x) 0 (+ 1 (head x))))
\end{lstlisting}
In other words, a possible solution for $f$ returns zero whenever its
argument is the empty list ${\tt nil}$, 
and returns one plus the head of its argument otherwise.

\paragraph{Bit-Vectors with Concatenation and Extraction}

Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((BV32 (_ BitVec 32)) (BV16 (_ BitVec 16)))
   ((BV32 (_ BitVec 32) (#x00000000 #x00000001 #xFFFFFFFF
                         x
                         (bvand BV32 BV32)
                         (bvor BV32 BV32)
                         (bvnot BV32)
                         (concat BV16 BV16)
                         ))
    (BV16 (_ BitVec 16) (#x0000 #x0001 #xFFFF
                         (bvand BV16 BV16)
                         (bvor BV16 BV16)
                         (bvnot BV16)
                         ((_ extract 31 16) BV32)
                         ((_ extract 15 0) BV32)))))
(constraint (= (f #x0782ECAD) #xECAD0000))
(constraint (= (f #xFFFF008E) #x008E0000))
(constraint (= (f #x00000000) #x00000000))
(check-synth)
\end{lstlisting}
The this example, the logic is set to bitvectors ${\tt BV}$.
A single function-to-synthesize $f$ is given that takes a
32 bit bit-vector as input and returns a 32 bit bit-vector as output.
Its grammar involves non-terminals whose sorts are bit-vectors of
bit-width 32 and 16.
The semantics of the operators in this example are defined in the SMT-LIB standard.
In particular,
the operator ${\tt concat}$ concatenates its two arguments,
and the indexed operator ${\tt (\_\ extract\ n\ m)}$
returns a bit-vector containing bits $n$ through $m$ of its
argument, where $n \geq m$.
A possible correct solution for $f$ is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x (_ BitVec 32))) (_ BitVec 32) 
   (concat ((_ extract 15 0) x) #x0000))
\end{lstlisting}
In other words, a possible solution for $f$ 
returns the concatenation of bits $15$ to $0$ of its argument
with the the bit-vector $\#x0000$.

\paragraph{Grammars with Defined Symbols and Forward Declarations}
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(set-feature :fwd-decls true)
(set-feature :recursion true)
(define-fun x_plus_one ((x Int)) Int (+ x 1))
(synth-fun f ((x Int)) Int
   ((I Int))
   ((I Int (0 1 x (x_plus_one I)))))
(define-fun fx_plus_one ((x Int)) Int (+ (f x) 1))
(synth-fun g ((x Int)) Int
   ((I Int))
   ((I Int (0 1 x (fx_plus_one I)))))
(synth-fun h ((x Int)) Int
   ((I Int))
   ((I Int (0 1 x (h I)))))
(declare-var y Int)
(constraint (= (h y) (- (g y) (f y))))
(check-synth)
\end{lstlisting}
This example contains three well-formed $\synthfunkwd$ commands.
The first one for function $f$ contains an application of a macro ${\tt x\_plus\_one}$,
which abbreviates adding one to its argument.
This grammar is allowed in the default SyGuS logic
and in this example.
The grammar for $g$ contains an application of a macro ${\tt fx\_plus\_one}$,
whose exanded form contains a previously declared function-to-synthesize $f$.
This grammar is allowed since the feature $\ffwddeclskwd$ is enabled in this example.
The grammar for $h$ contains $h$ itself, and thus is allowed since $\frecursionkwd$ is
enabled in this example.
A possible correct response from the synthesis solver in this example is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x Int)) Int x)
(define-fun g ((x Int)) Int (fx_plus_one x))
(define-fun h ((x Int)) Int 1)
\end{lstlisting}
Notice the above definitions for $f$, $g$, and $h$ are given 
in the order in which they were introduced via $\synthfunkwd$ commands
in the input.

\bibliographystyle{plain}
\bibliography{references}

\begin{appendix}

\section{Reserved Words}
\label{apx:reserved}

A \emph{reserved word} is any of the 
literals from Section~\ref{ssec:literals},
or any of the following keywords:
$\checksynthkwd$,
$\constantkwd$,
$\constraintkwd$,
$\dtdeclkwd$,
$\dtsdeclkwd$,
$\sortdeclkwd$,
$\vardeclkwd$,
$\fundefkwd$,
$\sortdefkwd$,
$\existskwd$,
$\forallkwd$,
$\constraintinvkwd$,
$\letkwd$,
$\setfeaturekwd$,
%$\setfeaturesetkwd$,
$\setlogickwd$,
%$\setlogicinputkwd$,
%$\setlogicoutputkwd$,
$\setoptkwd$,
$\synthfunkwd$,
$\synthinvkwd$, and
$\varkwd$.


\section{Reference Grammars}
\label{apx:ref-grammars}

In this section, for convenience, we provide the concrete syntax for
grammars that generate exactly the set of terms 
that belong to SMT-LIB logics of interest for a fixed set of free variables.
In particular, this means that each of the following $\synthfunkwd$
commands are equivalent to those in which no grammar is provided.
Note this is not intended to be a complete list of logics.
In particular, we focus on logics that include a single background theory
whose sorts are not parametric.
Each of these grammars are derived
based on the definition of logics and theories
described in the theory and logic declaration documents
available at \url{www.smt-lib.org}.

For each grammar, we omit 
the predicate symbols that are shared by all logics
according to the SMT-LIB standard, that is,
those included in the core theory described in Section~\ref{ssec:smt-logic},
which includes Boolean connectives and equality.
We provide the grammar
for a single function over one of the sorts in the logic,
and assume it has one variable in its argument list
for each non-Boolean sort that the grammar contains.

\subsection{Integer Arithmetic}

The following grammar for $f$
generates exactly the integer-typed terms in the logic of
linear integer arithmetic (LIA) with one free integer variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(synth-fun f ((x Int)) Int
   ((y_term Int) (y_cons Int) (y_pred Bool))
   ((y_term Int  (y_cons
                  (Variable Int)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_cons y_term)
                  (* y_term y_cons)
                  (div y_term y_cons)
                  (mod y_term y_cons)
                  (abs y_term)
                  (ite y_pred y_term y_term)))
    (y_cons Int  ((Constant Int)))
    (y_pred Bool ((> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term
                  (<= y_term y_term))))))
\end{lstlisting}
Above, ${\tt div}$
denotes integer division,
${\tt mod}$ denotes integer modulus and ${\tt abs}$ denotes
the absolute value function.
Positive integer constants and zero are written using the syntax
for numerals $\intconst$. Negative integer constants
are written as the unary negation of a positive integer constant.

The following grammar for $g$ generates exactly the integer-typed terms in the logic of
non-linear integer arithmetic (NIA)
with one free integer variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic NIA)
(synth-fun g ((x Int)) Int
   ((y_term Int) (y_pred Bool))
   ((y_term Int  ((Constant Real) 
                  (Variable Int)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_term y_term)
                  (div y_term y_term)
                  (mod y_term y_term)
                  (abs y_term)
                  (ite y_pred y_term y_term)))
    (y_pred Bool (...
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term
                  (<= y_term y_term))))))
\end{lstlisting}

\subsection{Real Arithmetic}

The following grammar for $f$
generates exactly the real-typed terms in the logic of
linear real arithmetic (LRA)
with one free real variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LRA)
(synth-fun f ((x Real)) Real
   ((y_term Real) (y_cons Real) (y_pred Bool))
   ((y_term Real (y_cons 
                  (Variable Real) 
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_cons y_term)
                  (* y_term y_cons)
                  (ite y_pred y_term y_term)))
    (y_cons Real ((Constant Real)))
    (y_pred Bool (...
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term
                  (<= y_term y_term))))))
\end{lstlisting}
Notice that positive real constants and zero can either be written 
as decimal values using the syntax $\realconst$
or as rationals, e.g. the division of two numerals
${\tt (/\ m\ n)}$ where $n$ is not zero.
Negative reals are written either as the unary negation of decimal value 
or a rational of the form ${\tt (/\ (-\ m)\ n)}$ for numerals $m$ and $n$
where $n$ is not zero.

The grammar for $g$
generates exactly the real-typed terms in the logic of
non-linear real arithmetic (NRA)
with one free real variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic NRA)
(synth-fun g ((x Real)) Real
   ((y_term Real) (y_cons Real) (y_pred Bool))
   ((y_term Real ((Constant Real) 
                  (Variable Real)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_term y_term)
                  (/ y_term y_term)
                  (ite y_pred y_term y_term)))
    (y_pred Bool (...
                  (= y_term y_term)
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term
                  (<= y_term y_term))))))
\end{lstlisting}

\subsection{Fixed-Width Bit-Vectors}

The signature of bit-vectors includes an indexed sort
${\tt BitVec}$, which is indexed by an integer constant that denotes
its bit-width. We show a grammar below for one particular
choice of this bit-width, $32$.
We omit indexed bit-vector operators
such as extraction function ${\tt (\_\ extract\ n\ m)}$, 
the concatenation function ${\tt concat}$,
since these operators are polymorphic.
For brevity,
we also omit the \emph{extended} operators of this theory
as denoted by SMT-LIB,
which includes functions like
bit-vector subtraction ${\tt bvsub}$,
xor ${\tt bvxor}$,
signed division ${\tt bvsdiv}$,
and predicates like
unsigned-greater-than-or-equal ${\tt bvuge}$
and signed-less-than ${\tt bvslt}$.
These extended operators can be seen as syntactic sugar for the
operators in the grammar below.
Example inputs that involve 
some of the omitted operators are given in Section~\ref{sec:examples}.

% ajr: full grammar 
\begin{comment}
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((y_term (_ BitVec 32)) (y_pred Bool))
   ((y_term (_ BitVec 32) ((Constant (_ BitVec 32))
                           (Variable (_ BitVec 32))
                           (bvnot y_term)
                           (bvand y_term y_term)
                           (bvor y_term y_term)
                           (bvneg y_term)
                           (bvadd y_term y_term)
                           (bvmul y_term y_term)
                           (bvudiv y_term y_term)
                           (bvurem y_term y_term)
                           (bvshl y_term y_term)
                           (bvlshr y_term y_term)
                           (bvnand y_term y_term)
                           (bvnor y_term y_term)
                           (bvxor y_term y_term)
                           (bvxnor y_term y_term)
                           (bvsub y_term y_term)
                           (bvsdiv y_term y_term)
                           (bvsrem y_term y_term)
                           (bvsmod y_term y_term)
                           (bvashr y_term y_term)
                           (ite y_pred y_term y_term)))
    (y_pred Bool (...
                  (bvult y_pred y_pred)
                  (bvule y_pred y_pred)
                  (bvugt y_pred y_pred)
                  (bvuge y_pred y_pred)
                  (bvslt y_pred y_pred)
                  (bvsle y_pred y_pred)
                  (bvsgt y_pred y_pred)
                  (bvsge y_pred y_pred))))))
\end{lstlisting}
\end{comment}
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((y_term (_ BitVec 32)) (y_pred Bool))
   ((y_term (_ BitVec 32) ((Constant (_ BitVec 32))
                           (Variable (_ BitVec 32))
                           (bvnot y_term)
                           (bvand y_term y_term)
                           (bvor y_term y_term)
                           (bvneg y_term)
                           (bvadd y_term y_term)
                           (bvmul y_term y_term)
                           (bvudiv y_term y_term)
                           (bvurem y_term y_term)
                           (bvshl y_term y_term)
                           (bvlshr y_term y_term)
                           (ite y_pred y_term y_term)))
    (y_pred Bool (...
                  (bvult y_pred y_pred))))))
\end{lstlisting}
Bit-vector constants may be specified
using either the hexadecimal format $\hexconst$
or the binary format $\binaryconst$.


\subsection{Strings}

Notice that there is no
officially adopted SMT-LIB standard for strings at the time
this document was written.
Thus, we adopt (a subset of) the proposed standard~\cite{smtlibStrings}
as of \rem{fixed time}.
Here, we omit discussion of regular expressions and characters.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic S)
(synth-fun f ((xs String) (xi Int)) String
   ((y_term_str String) (y_term_int String) (y_pred Bool))
   ((y_term_str String ((Constant String)
                        (Variable String)
                        (str.++ y_term_str y_term_str)
                        (str.at y_term_str y_term_str)
                        (str.substr y_term_str y_term_int y_term_int)
                        (str.indexof y_term_str y_term_str y_term_int)
                        (str.replace y_term_str y_term_str y_term_str)
                        (str.from-int y_term_int)
                        (ite y_pred y_term_str y_term_str)))
   ((y_term_int String ((Variable Int)
                        (str.len y_term_str)
                        (str.to-int y_term_str)
                        (ite y_pred y_term_int y_term_int)))
    (y_pred Bool (...
                  (str.contains y_term_str y_term_str)
                  (str.prefixof y_term_str y_term_str)
                  (str.suffixof y_term_str y_term_str)
                  (str.< y_term_str y_term_str)
                  (str.<= y_term_str y_term_str))))))
\end{lstlisting}
% ===== RE
%str.to-re
%str.from-re
%re.none
%re.all
%re.allchar
%re.++
%re.union
%re.inter
%re.*
%str.<=
%re.+
%re.opt
%re.range
%re.^
%re.loop
% ===== characters
%str.char
%str.is-digit
%char.code
%char.from-int
String constants may be specified by text delimited by double quotes
based on the syntax $\stringconst$ described in Section~\ref{ssec:literals}.

Notice that since the logic specified above is ${\tt S}$.
The signature of this logic includes 
some functions involving the integer sort like
${\tt str.len}$.
However, the above logic does not permit inputs containing
integer constants or the standard symbols of arithmetic like 
${\tt +}, {\tt -}$, ${\tt >=}$ and so on, since the logic ${\tt S}$
does not include the theory of integer arithmetic.
Thus in pratice, 
the string theory is frequently combined with the theory of integers
in the logic ${\tt SLIA}$, i.e. strings with linear integer arithmetic.


\section{Language Features of SMT-LIB not Covered}

For the purpose of self-containment,
many of the essential language features of SMT-LIB version 2.6
are redefined in this document.
However, other less essential ones are omitted.
%We do not explicitly forbid the language features of SMT-LIB .
We briefly mention other language features not mentioned in
this document.
We do not require solvers to support these features.
However, we recommend that if solvers support any of the features below,
they use SMT-LIB compliant syntax, as described briefly below.
%\rem{Recommended that if using these, then they are used in this way}

\paragraph{Parametric Datatype Definitions}
We do not cover the concrete syntax or semantics of parametric datatypes (that
is, datatypes whose arity is non-zero) in this document.
An example of a datatype definition for a parametric list is given below.
\begin{lstlisting}[basicstyle={\ttfamily}]
(declare-datatypes ((List 1)) (
  (par (T) ((nil) (cons (head T) (tail (List T)))))))
\end{lstlisting}
Above, the datatype ${\tt List}$ 
is given in the predeclaration with the numeral ${\tt 1}$, indicating
its arity is one.
The datatype definition that follows includes quantification on a type
parameter ${\tt T}$, where this quantification is specified using the 
${\tt par}$ keyword. Within the body of this quantification,
a usual constructor listing is given, where the type parameter ${\tt T}$
may occur free. The constructors of this datatype are ${\tt nil}$
and ${\tt cons}$.

\paragraph{Qualified Identifiers}
In SMT-LIB version 2.6,
identifiers that comprise terms
may be \emph{qualified} with a type-cast, using the keyword $\askwd$.
Type casts are required for symbols whose type is ambiguous,
such as parametric datatype constructors, e.g. the nil constructor
for a parametric list
For the parametric datatype above, 
${\tt (as\ nil\ (List\ Int))}$ and ${\tt (as\ nil\ (List\ Real))}$ 
denote the type constructors
for the empty list of integers and reals respectively.

\paragraph{Match Terms}
The SMT-LIB version 2.6 includes a ${\tt match}$ term
that case splits on the constructors of datatype terms.
For example,
the match term:
\begin{lstlisting}[basicstyle={\ttfamily}]
(match x ((nil (- 1)) ((cons h t) h)))
\end{lstlisting}
returns negative one if the list $x$ is empty,
or the first element of $x$ (its head) if it is non-empty.

\paragraph{Recursive Functions}
The SMT-LIB version 2.6 includes a command $\recfundefkwd$
for defining symbols that involve recursion.\footnote{
Recall that recursive definitions are prohibited from macro definitions in the command
$\fundefkwd$.
}
An example, which computes the length of a (non-parametric) list 
is given below.
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun-rec len ((x List)) Int 
  (match x ((nil 0) ((cons h t) (+ 1 (len t))))))
\end{lstlisting}
Functions may be defined to be mutually recursive by declaring
them in a single block using the $\recfunsdefkwd$ command.
An example, which defines two predicates ${\tt isEven}$ and ${\tt isOdd}$
for determining whether a positive integer is even and odd respectively,
is given in the following.
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-funs-rec (
  (isEven ((x Int)) Bool)
  (isOdd ((x Int)) Bool)
)(
  (ite (= x 0) true (isOdd (- x 1)))
  (ite (= x 0) false (isEven (- x 1)))
))
\end{lstlisting}
Notice that recursive function definitions are not required to be terminating
(the above functions do not terminate for negative integers).
They are not even required to correspond to consistent definitions, for instance:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun-rec inconsistent ((x List)) Int 
  (+ (inconsistent x) 1))
\end{lstlisting}
The semantics of recursive functions is given in 
the SMT-LIB version 2.6 standard~\cite{BarFT-RR-17}.
Each recursive function can be seen as a universally quantified constraint
that asserts that each set of values in the domain of the function
is equal to its body.
%An example, which computes the number of nodes in a tree with 
%an aribtrary number of children, is given below.
%\begin{lstlisting}[basicstyle={\ttfamily}]
%(declare-datatypes ((Tree 0) (CList 0)) (
%  ((leaf) (node (children CList)))
%  ((nil) (cons (head Tree) (tail List)))
%))
%\end{lstlisting}

%The semantics of recursive functions in SyGuS inputs
%is planned to be incorporated in later revisions of this document.

\paragraph{Attribute Annotations}
In SMT-LIB,
terms $t$ may be annotated with \emph{attributes}.
The purpose of an attribute is to mark a term with a set of special properties, 
which may influence the expected result of later commands.
Attributes are specified using the
syntax $\paren{!\mbox{ }t\mbox{ }\kstar{A}}$
where $t$ is a term and $A$ is an attribute.
The syntax for attributes (not given here) is similar to the one
for specifying options and features in this document.
The term above is semantically equivalent to $t$ itself.
Several attributes are standardized by the SMT-LIB standard, while
others may be user-defined.

\paragraph{Additional Logics and Theories}
Several standard logics and theories are omitted from discussion in this document.
This includes the (mixed) theory of integers and reals,
the theory of floating points,
the integer and real difference logic,
and their combinations.
More details on the catalog of logics and theories in the SMT-LIB standard
is available at \url{www.smt-lib.org}.

\end{appendix}


\end{document}
