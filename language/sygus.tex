\pdfoutput=1

\documentclass[english,a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage{xspace}
\usepackage[unicode=true,
            pdfusetitle,
            bookmarks=true,
            bookmarksnumbered=false,
            bookmarksopen=false,
            breaklinks=false,
            pdfborder={0 0 0},
            backref=false,
            colorlinks=true,
            citecolor=blue]
 {hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{comment}
\usepackage{amsthm}
\usepackage[noabbrev,capitalize,nameinlink]{cleveref}

\usepackage{enumitem}
\setenumerate{itemsep=0.25em,topsep=0.25em,leftmargin=2em}
\setitemize{itemsep=0.25em,topsep=0.25em,leftmargin=2em}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{The SyGuS Language Standard Version 2.1}

\author{Elizabeth Polgreen \and Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle

\input{macros}
\input{sygus-macros}

\input{introduction}

%\ajr{Intro to sygus and example}

\paragraph{Overview of This Document}
This document defines the SyGuS format version 2.0,
which is intended to be used as the standard input and output language
for solvers targeting the syntax-guided synthesis problem.
The language borrows many concepts and language constructs
from the standard format for Satisfiability Modulo Theories (SMT)
solvers, the SMT-LIB standard (version 2.6)~\cite{BarFT-RR-17}.

\begin{comment}
We would like to thank the following people for their helpful
suggestions and feedback regarding this document (listed alphabetically):
Haniel Barbosa,
Andres N\"otzli,
Saswat Padhi,
Sanjit A.~Seshia,
Rishabh Singh,
Cesare Tinelli.
\end{comment}

\paragraph{Outline}
In the remainder of this section, we cover differences of
the SyGuS format described in this document with previous revisions~\cite{sygusFormat,sygusSyntax2015,sygusSyntax2016}
and cover the necessary preliminaries.
Then,
\cref{sec:syntax}
gives the concrete syntax for commands in the SyGuS input language.
\cref{sec:semantics}
documents the well-formedness and the semantics of input commands.
\cref{sec:output}
documents the expected output of synthesis solvers in response to these commands.
\cref{sec:sygus-logic}
describes formally the notion of a \emph{SyGuS logic} and how it restricts
the set of commands that are allowed in an input.
\cref{sec:logical-semantics}
formalizes what constitutes a correct response to a SyGuS input.
Finally, \cref{sec:examples}
provides examples of possible inputs in the SyGuS language
and solvers responses to them.

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
version of the SyGuS format~\cite{sygusFormat},
and its extensions~\cite{sygusSyntax2015,sygusSyntax2016}.
\subsubsection{Changes from SyGuS 1.0 to SyGuS 2.0}
\begin{enumerate}

\item The syntax for providing grammars inside the $\synthfunkwd$ command
now requires that non-terminal symbols are declared upfront
in a \emph{predeclaration}, see \cref{ssec:dec-synth-fun}
for details.
%\rem{Mention Start symbol change if applicable.}

\item 
The keyword ${\tt Start}$, which 
denoted the starting (non-terminal) symbol of
grammars in the previous standard, has been removed.
Instead, the first symbol listed in the grammar is assumed
to be the starting symbol.

\item 
Terms that occur as the right hand side of production rules in
SyGuS grammars are now required to be binder-free.
In particular, this means that let-terms are now disallowed within grammars.
Accordingly,
the keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed since the former is equivalent to $\varkwd$
and the latter has no affect on the grammar.

\item The datatype keyword $\enumkwd$
and related syntactic features have been removed.
The standard SMT-LIB 2.6 commands
for declaring datatypes are now adopted,
see \cref{ssec:declaring-sorts} for details.

\item The $\setoptskwd$ command has been renamed $\setoptkwd$ to 
correlate to the existing SMT-LIB version 2.6 command.

\item 
The syntax for terms and sorts
now coincides with the corresponding syntax for terms and sorts 
from SMT-LIB versions 2.0 and later.
There are three notable changes
with respect to the previous SyGuS format that come as a result of this change.
First,
negative integer and real constants must be written with
unary negation, that is, the integer constant negative one
must be written ${\tt (-\ 1)}$, whereas previously it could
be written ${\tt -1}$.
Second,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Third,
all let-bindings do \emph{not} annotate the type of the variable being bound.
Previously, a let-term was written ${\tt (let\ ((x\ T\ t)) ...)}$
where ${\tt T}$ indicates the type of ${\tt t}$.
Now, it must be written in the SMT-LIB compliant
way ${\tt (let\ ((x\ t)) ...)}$.

\item
The signature, syntax and semantics for the theory of strings
is now the one given in an initial proposal~\cite{smtlibStrings} to SMT-LIB.
Thus, certain new symbols are now present in the signature,
and some existing ones have changed names.
For example,
the conversion functions between strings and their integer representations
${\tt str.to.int}$ and ${\tt int.to.str}$ have been renamed to
${\tt str.to}$-${\tt int}$ and ${\tt str.from}$-${\tt int}$.
The semantics of all operators,
which was not specified previously,
is now consistent with that provided in the proposal~\cite{smtlibStrings}.

%Furthermore, wherever applicable,
%the syntax for sorts and terms
%from other SMT theories assumes the syntax
%prescribed in theory definitions from SMT-LIB~\cite{}.

\item The command $\primedvardeclkwd$, which was a syntactic
sugar for two $\vardeclkwd$ commands in the previous language standard, has been removed
for the sake of simplicity.
This command did not provide any benefit to
invariant synthesis problems, since constraints declared via $\constraintinvkwd$
do not accept global variables.
%\rem{TODO: This command is not used properly in current
%invariant synthesis benchmarks (since variables cannot be passed
%to inv-constraint commands), and only contributes
%to confusion, in my opinion. Ok to remove?
%}

%\item Change (fail)?

%\item Elaborations on the well-formedness of all commands.

\item 
The command $\fundeclkwd$,
which declared a universal variable of function type
in the previous language standard,
has been removed.
%Solvers that wish to support synthesis conjectures
%with higher-order quantification

\item
A formal notion of \emph{input logics}, \emph{output logics}, and 
\emph{features} have been defined as part of the SyGuS background logic,
and the command $\setfeaturekwd$ %and $\setfeaturesetkwd$
has been added to the language,
which is used for further refining
the constraints, grammars and commands that may appear in an input.

\item The expected output for fail responses from a solver has changed.
In particular,
the response ${\tt (fail)}$ from the previous language standard
should now be provided as ${\tt fail}$, that is, without parentheses.
Additionally, a solver may answer ${\tt infeasible}$, indicating
that it has determined there are no solutions to the given conjecture.

\end{enumerate}
\subsubsection{Changes from SyGuS 2.0 to SyGuS 2.1}
\begin{enumerate}
\item We introduce the command $\assumekwd$, which introduces a list of assumptions $\alpha$, and the 
synthesis conjecture is now 
$\exists f_1, \ldots, f_n \forall v_1, \ldots,
v_m. \alpha \implies \varphi$. 
\item Oracle constraints are introduced. Oracle constraints are constraints that are generated when an external oracle is called with a concrete set of input values. The constraints are conjoined to list of constraints $\varphi$ in the synthesis conjecture. 

\item Oracle assumptions are introduced. Oracle assumptions are assumptions that are generated when an external oracle is called with a concrete set of input values. The assumptions are conjoined to the list of assumptions $\alpha$ in the synthesis conjecture.

\item Oracle Functions are introduced. These are functional symbols whose interpretation is associated to an external oracle. The functions are treated as universally quantified uninterpreted functions, and calls to that external oracle place with concrete input values generate assumptions over the behaviour of the uninterpreted function. These assumptions are conjoined to the list of assumptions $\alpha$ in the synthesis conjecture.

\item A set of new commands are introduced to enable easy specification of specific types of oracles, for instance input-output oracles. These oracles are based on the formalization by Jha and Seshia~\cite{oracles}.
\end{enumerate}


\subsection{Preliminaries}
In this document, we assume basic standard notions of
multi-sorted first-order logic.
We assume the reader is familiar
with sorts, well-sorted terms, (quantified) formulas
and free variables\footnote{
The definition of each of these coincides with
the definition given in the SMT-LIB 2.6 standard~\cite{BarFT-RR-17}.
}
If $e$ is a term or formula,
then we write $e[x]$ to denote that $x$ occurs free in $e$,
and $e[t]$ to denote the result of replacing all occurrences of $x$ by $t$.
We write $\lambda \vec{x}.\, t[\vec{x}]$ to denote a \emph{lambda term},
that is, an anonymous function whose argument list is $\vec{x}$
that returns the value of $t[\vec{s}]$ for all inputs $\vec{x} = \vec{s}$.
Given an application of a lambda term to a concrete argument list $\vec{s}$,
i.e. the term $(\lambda \vec{x}.\, t[\vec{x}])( \vec{s} )$,
then its \emph{beta-reduction} is the term $t[\vec{s}]$.
%In this document, we consider only \emph{simple} lambda terms 
%whose body itself contains no lambda terms.

\section{Syntax}
\label{sec:syntax}

In this section, we describe the concrete syntax
for the SyGuS 2.0 input language.
Many constructs in this syntax coincide
with those in SMT-LIB 2.6 standard~\cite{BarFT-RR-17}.
In the following description,
italic text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]
We first introduce the necessary preliminary definitions,
and then provide the syntax for commands $\cmd$ at the end of this section.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a semicolon, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters,
typically used to denote values or constant terms.
The SyGuS format includes syntax for several kinds of literals,
which are listed below.
This treatment of most of these literals coincides with
those in SMT-LIB version 2.6.
For full details, see Section 3.1 of the SMT-LIB 2.6 standard~\cite{BarFT-RR-17}.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\end{array}
\end{alignat*}

\paragraph{Numerals ($\intconst$)}
Numerals are
either the digit $0$,
or a non-empty sequence of digits $\left[{\tt 0}-{\tt 9}\right]$
that does not begin with $0$.

\paragraph{Decimals ($\realconst$)}
The syntax for decimal numbers is $\intconst{\tt .\kstar{0}}\intconst$.

\paragraph{Booleans ($\boolconst$)}
Symbols $\truekwd$ and $\falsekwd$ denote the Booleans true and false.

\paragraph{Hexidecimals ($\hexconst$)}
Hexadecimals are written with ${\tt \#x}$
followed by a non-empty sequence of (case-insensitive) 
digits and letters taken from the ranges $\left[{\tt A}-{\tt F}\right]$
and $\left[{\tt 0}-{\tt 9}\right]$.

\paragraph{Binaries ($\binaryconst$)}
Binaries are written with ${\tt \#b}$
followed by a non-empty sequence of bits $\left[{\tt 0}-{\tt 1}\right]$.

\paragraph{Strings ($\stringconst$)}
A string literal $\stringconst$
is any sequence of printable characters
delimited by double quotes $\texttt{"}$ $\texttt{"}$.
The characters within these delimiters
are interpreted as denoting characters of the string in a one-to-one correspondence,
with one exception:
two consecutive double quotes within a string
denote a single double quotes character.
In other words, $\texttt{"}{\tt a}\texttt{"}\texttt{"}{\tt b}\texttt{"}$ denotes the string
whose characters in order are ${\tt a}$, $\texttt{"}$ and ${\tt b}$.
Strings such as $\texttt{"}{\tt \backslash n}\texttt{"}$ whose characters are commonly
interpreted as escape sequences are not handled specially,
meaning this string is interpreted 
as the one consisting of two characters, ${\tt \backslash}$ followed by ${\tt n}$.
%\rem{TODO: double quotes within strings escape, no other escape}

\ 

\noindent
Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses numerals to denote non-negative integer values.
The theory of bit-vectors uses both
hexadecimal and binary constants in the above syntax
to denote bit-vector values.
%For more details on common theories,
%see \cref{ssec:smt-logic}.

\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see \cref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with simple
symbols in Section 3.1 of SMT-LIB version 2.6,
apart from differences in their reserved words.

\subsection{Identifiers}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes symbols that are indexed by integer constants or other symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of SMT-LIB version 2.6.

\subsection{Sorts}

We work in a multi-sorted logic where terms 
are associated with sorts $\sortexpr$.
Sorts are constructed via the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
\sortexpr & ::= & \identifier\mbox{ }|\mbox{ }\paren{\identifier\mbox{ }\kplus{\sortexpr}}\\
\end{array}
\end{alignat*}
The \emph{arity} of the sort is the number of (sort) arguments it takes.
A \emph{parametric} sort is one whose arity is greater than zero.
Theories associate identifiers with sorts and sort constructors
that have an intended semantics.
Sorts may be defined by theories (see examples in \cref{ssec:smt-logic})
or may be user-defined
(see \cref{ssec:declaring-sorts}).

\subsection{Terms}

We use terms $\term$ to specify grammars and constraints,
which are constructed by the following syntax.
% ajr: version including qualified identifiers (perhaps too verbose)
\begin{comment}
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \qualidentifier & ::= & \identifier\mbox{ }|\mbox{ }\paren{\askwd\mbox{ }\identifier\mbox{ }\sortexpr}\\
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Above,
we distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain bound (local) variables.
Identifiers that comprise terms
may be \emph{qualified} with a type-cast, using the keyword $\askwd$.
Type casts are used for symbols whose type is ambiguous,
such as parametric datatype constructors, e.g. the nil constructor
for a parametric list.

Like sorts, the identifiers that comprise terms
can either be defined by the user or by background theories.
Examples of the latter are given in \cref{ssec:smt-logic}.
\end{comment}
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \identifier\\
 & | & \literal\\
 & | & \paren{\identifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \identifier\\
 & | & \literal\\
 & | & \paren{\identifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Above,
we distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain bound (local) variables.
Like sorts, the identifiers that comprise terms
can either be defined by the user or by background theories.
%Examples of the latter are given in \cref{ssec:smt-logic}.

\subsection{Features}
\label{ssec:syntax-features}

A feature $\feature$ denotes a restriction or extension
on the kinds of SyGuS commands that are allowed in an input.
It is an enumeration in the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
 \feature & ::= & \fgrammarskwd\mbox{ }|\mbox{ }\ffwddeclskwd\mbox{ }|\mbox{ }\frecursionkwd\mbox{ }|\mbox{ } \foracleskwd\mbox{ }
 % ajr: not needed
 %|\mbox{ }\fquantifierskwd
\end{array}
\end{alignat*}
More details on features are given in \cref{ssec:feature-sets}.

\subsection{Commands}

A command $\cmd$ is given by the following syntax.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\checksynthkwd} \\
 & | & \paren{\constraintkwd\mbox{ }\term} \\
  & | & \paren{\assumekwd\mbox{ }\term} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setfeaturekwd\mbox{ }:\feature\mbox{ }\boolconst} \\
% & | & \paren{\setfeaturesetkwd\mbox{ }\symbol} \\
% & | & \paren{\setlogicinputkwd\mbox{ }\symbol} \\
% & | & \paren{\setlogicoutputkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \oraclecmd \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 % ajr: removed
 %\paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= &\paren{\dtdeclkwd\mbox{ }\symbol\mbox{ }\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setinfokwd\mbox{ }:\symbol{ }\literal} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }:\symbol\mbox{ }\literal} \\[2ex]

\oraclecmd 
& ::= & \paren{\assumeoraclekwd\mbox{ }\symbol\mbox{ } \paren{\kstar{\sortedvar}}\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }
 \term} \\
 & | & \paren{\constraintoraclekwd\mbox{ }\symbol\mbox{ } \paren{\kstar{\sortedvar}}\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }
 \term} \\
& | & \paren{\oracledeckwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }} \\
& | &\paren{\iooracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\cexoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\memoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
% & | &\paren{\dioracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\poswitnessoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\negwitnessoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\corroracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\
& | &\paren{\corrcexoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\[2ex]
% & | &\paren{\falsifyoracledeckwd\mbox{ }\symbol\mbox{ } \symbol\mbox{ }} \\[2ex]



 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 %\sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\  %ajr: used above
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\sortexpr\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\paren{\varkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\bfterm\\
\end{array}
\]
For convenience,
we distinguish between two kinds of commands above.
The commands listed under $\cmd$ and $\oraclecmd$ are specific to the SyGuS 2.0 format.
The remaining commands listed under $\smtcmd$
are borrowed from SMT-LIB 2.6.
Details on the semantics of these commands are given in \cref{sec:semantics}.

%\paragraph{Reserved Words}
%All strings mentioned in \cref{ssec:literals}

\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands,
which at a high level
are used for defining a (single) synthesis conjecture,
and invoking a solver for this conjecture.
This conjecture is a closed formula of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall v_1,\ldots,v_m.\,(\alpha_1 \wedge \ldots \wedge \alpha_r) \implies (\varphi_1 \wedge \ldots \wedge \varphi_q )
\end{alignat*}
We wil use $\Psi$ to refer to the formula $\forall v_1,\ldots,v_m.\,(\alpha_1 \wedge \ldots \wedge \alpha_r)\implies (\varphi_1 \wedge \ldots \wedge \varphi_q )$, and thus the synthesis conjecture can be written $\exists f_1,\ldots,f_n.\, \Psi$. 
In this section, we define how this conjecture is
is established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 
Given a sequence of commands, the current state consists of the following
information:
\begin{itemize}
\item A list
$f_1, \ldots, f_n$, which we refer to
as the current list of \emph{functions to synthesize},
\item A list 
$v_1, \ldots, v_m$ of variables, 
which we refer to as the current list of \emph{universal variables},
\item A list of formulas
$\varphi = \varphi_1, \ldots, \varphi_q$,
which we refer to as the current list of \emph{constraints},
\item A list of formulas
$\alpha = \alpha_1, \ldots, \alpha_r$,
which we refer to as the current list of \emph{assumptions},
\item A \emph{signature}
denoting the set of defined symbols in the current scope.
A signature is 
a mapping from symbols to expressions (either sorts or terms).
Each of these symbols may have a predefined semantics
either given by the theory,
or defined by the user (e.g. symbols that are defined as macros
fit the latter category).
\item A \emph{SyGuS logic} denoting the
terms and sorts that may appear in constraints and grammars.
\end{itemize}
In the initial state of a SyGuS input,
the lists of functions-to-synthesize, 
universal variables, constraints, assumptions, and the signature are empty,
and the SyGuS logic is the default one 
(see \cref{sec:sygus-logic} for details).  
%that is, 
%no restrictions are placed on the set of terms that may appear 
%in constraints and grammars.

In the following, we first describe restrictions
on the order in which commands can be specified in SyGuS inputs.
We then describe how each command $\cmd$ updates
the state of the sets above and the current signature.

\subsection{Command Ordering}
A SyGuS input is not well-formed
if it specifies a list of commands that do not meet
the restrictions given in this section regarding their order. The
order is specified by the following regular pattern:

\vspace*{2mm}
\noindent
\begin{equation*}
(\mathit{\{ set\ logic\ command \}})?\mbox{ }\mathit{(\{setter\ commands\})^*\mbox{ }(\{other\ commands\})^*}
\end{equation*}
where the set $\mathit{\{set\ logic\ command\}}$ consists
of the set of all $\setlogickwd$ commands,
set $\mathit{\{setter\ commands\}}$ includes
the \texttt{set-feature} and \texttt{set-option}
commands, the set $\mathit{\{other\ commands\}}$ include all the SyGuS
commands except the commands in the aforementioned two sets.

In other words, a SyGuS input is well formed if it begins with 
at most one \texttt{set-logic} command, followed by 
a block of zero or more \texttt{set-feature}
and \texttt{set-option} commands in any order, 
followed by zero or more instances of the other SyGuS commands.

\subsection{Setting the Logic}
\label{ssec:set-logic}
The logic of a SyGuS specification consists of three parts ---
an \emph{input logic}, an \emph{output logic} and a \emph{feature set}.
Roughly, 
the input logic determines what terms
can appear in constraints and
the output logic determines
what terms can appear in grammars and solutions.
The feature set places additional restrictions or extensions 
on the constraints, grammars as well as the commands that are allowed in an input.
These are described in detail in \cref{sec:sygus-logic}.

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }S}$

This sets the SyGuS background logic
to the one that $S$ refers to.
The logic string $S$ can be a standard one defined in the SMT-LIB 2.6 standard~\cite{BarFT-RR-17}
or may be solver-specific.
If $S$ is an SMT-LIB standard logic,
then it must 
contain quantifiers or this command is not well-formed,
that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.\footnote{
By convention quantifiers are always included in the logic. This is because
the overall synthesis conjecture specified by the
state may involve universal quantification.
}
If this command is well-formed and $S$ is an SMT-LIB standard logic,
then this command sets the SyGuS logic to the one whose
input and output logics are ${\tt QF\_}S$ and whose feature
set is the default one defined in this document (\cref{ssec:feature-sets}).
In other words, when this command has $S$ as an argument
and $S$ is an SMT-LIB standard logic, this
indicates that that terms in the logic of $S$ are 
allowed in constraints, grammars and solutions, but they are
are restricted to be quantifier-free.
As a consequence, 
the overall synthesis conjectures 
allowed by default when $S$ is a standard SMT-LIB logic
%by symbols $S$ that correspond to SMT-LIB standard logics
have at most two levels of quantifier alternation.
%For examples of common SMT logics, 
%see \cref{ssec:smt-logic}.
%If $S$ is a standard SMT-LIB logic,
%then this command adds the set of sort and function symbols
%from that logic to the current signature.
%In this case,
%the logic must contain quantifiers or this command is not well-formed,
%that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.
%In SyGuS, notice that the logic gives
%restrictions on both the kinds of terms that
%may appear in constraints, and may appear in grammars.
%We give details on the default settings of the logic for SyGuS inputs
%in \cref{sec:sygus-logic}.
%In other words, the input logic is set to the quantifier-free
%version of the logic $S$ indicating that arbitrary quantified formulas
%cannot appear in constraints, and
%the output logic is set to $S$ itself.

\begin{comment}
\item $\paren{\setlogicinputkwd\mbox{ }S}$

This sets the input logic component of the SyGuS background logic
to the one $S$ refers to,
which can be a standard one defined in SMT-LIB~\cite{BarFT-RR-17}
or may be solver-specific.
%The logic must contain quantifiers or this command is not well-formed,\mbox{ }\tau_n
%that is, logics from the SMT-LIB standard 
%with the prefix ``${\tt QF\_}$'' are not allowed.
This command adds the set of sort and function symbols
from the logic to the current signature.
Some of the standard logics defined by SMT-LIB that can be an argument of this
command are given in \cref{ssec:smt-logic}.

\item $\paren{\setlogicoutputkwd\mbox{ }S}$

This sets the output logic component of the SyGuS background logic
to the one $S$ refers to.
This command imposes the same restrictions on logics
as the previous command, and adds the set of sort and function symbols
from the logic to the current signature.

\item $\paren{\setfeaturesetkwd\mbox{ }S}$

This sets the feature set component of the SyGuS background logic
to the one specified by symbol $S$.
We do not standardize any examples of feature sets
in this document.
We remark that a feature set may correspond to a class of synthesis problems,
for example, synthesis conjectures having
a single non-recursive function-to-synthesize.
%Setting a feature set is syntactic sugar
%for the appropriate sequence of $\setfeaturekwd$ commands.
\end{comment}

\item $\paren{\setfeaturekwd\mbox{ }:F\mbox{ }b}$

This enables the feature specified by $F$
in the feature set component of the SyGuS background logic
if $b$ is $\truekwd$, or disables it if $b$ is $\falsekwd$.
%This may affect the set of commands 
%allowed in an input,
%or further refinements to the restrictions placed
%on the set of allowed constraints and grammars.
All features standardized in SyGuS 2.0
are given in \cref{ssec:feature-sets}.

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }S\mbox{ }\sigma}$

This command appends $S$ to the current list of universal variables
and adds the symbol $S$ of sort $\sigma$ to the current signature.
This command should be rejected if $S$ already
exists in the current signature.

%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

%\item $\paren{\fundeclkwd\mbox{ }S\mbox{ }\paren{\sigma_1 \ldots \sigma_n}\mbox{ }\sigma}$

%This command adds $S$ to the current set of universal variables.
%The sort of $S$ is $\sigma$ if $n=0$ or
%$\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$ if $n>0$.
%This command should be rejected if $S$ is already
%a symbol in the current signature.

%\rem{This is higher-order quantification.
%TODO: rename this ``declare-var-fun''? Parallel with declare-const -> declare-var.
%Maybe remove this command.
%}

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}
\label{ssec:dec-synth-fun}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
\koption{G}}$

This command adds $S$ to the current list of functions to synthesize,
and adds the symbol $S$ of 
sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$
to the current signature.
This command should be rejected if $S$ is already
a symbol in the current signature.
We describe restrictions and well-formedness requirements for this command
in the following.

If provided, the syntax for the grammar $G$
consists of two parts: 
a \emph{predeclaration}
$\paren{\paren{y_1\mbox{ }\tau_1} \ldots \paren{y_n\mbox{ }\tau_n}}$,
followed by a \emph{grouped rule listing}
$\paren{\paren{y_1\mbox{ }\tau_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots \paren{y_n\mbox{ }\tau_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}$
where $y_1, \ldots, y_n$ are the \emph{non-terminal} symbols of the grammar.
Note that the same variable symbols
$y_1, \ldots, y_n$ and their sorts 
$\tau_1, \ldots, \tau_n$ appear both in the predeclaration and as heads
of each of the rules.
If this is not the case, then this command is not well-formed.
For all $i,j$, recall that grammar term $g_{ij}$ is either a term, or a class of terms
denoted by $\paren{\constantkwd\mbox{ }\sigma_c}$ 
and $\paren{\varkwd\mbox{ }\sigma_v}$ denoting respectively
the set of constants whose sort is $\sigma_c$,
and the set of all variables from $x_1, \ldots, x_n$ whose sort is $\sigma_v$.
If $g_{ij}$ is an ordinary term, then its free variables may contain $y_1, \ldots, y_n$,
as well as $S$ itself.
If the grammar contains $S$ itself, then it is possible that the definition
given for $S$ in a solution is recursive, however,
this feature is disallowed in the default logic (see \cref{sec:sygus-logic}).

This command is not well-formed if
$\tau_1$ (the type of the start symbol) is not $\sigma$.
%\rem{TODO: should we make the first symbol of list the start symbol, instead of distinguished Start keyword?},
It is also not well-formed if
$G$ generates a term $t$ from $y_i$
that does not have type $\tau_i$ for some $i$.

If provided, the grammar $G$ must also be one that is allowed
by the output logic of the current SyGuS logic.
For more details on the restrictions imposed on grammars by the logic,
see \cref{sec:sygus-logic}.
If $G$ does not meet the restrictions
of the background logic, it should be rejected.

If no grammar is provided,
then any term of the appropriate sort
in the output logic may be given in the body of a solution for $S$.

More details on grammars and the terms
they generate, as well as what denotes a term that meets the syntactic
restrictions of a function-to-synthesize
is discussed in detail in \cref{ssec:sat-syntactic}.

\begin{comment}
If $G$ is not provided,
then this command is syntax
sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
G_{\mathcal{L},\vec{x},\sigma}}$
where $G_{\mathcal{L},\vec{x},\sigma}$ is a grammar that
generates all well-sorted terms of sort $\sigma$ 
that belong to the language of the current background logic $\mathcal{L}$,
and whose free variables are in $\vec{x} = (x_1, \ldots, x_n)$.
%We call $G_{\mathcal{L},\sigma,\vec{x}}$ the \emph{default}
%grammar for $(T,\sigma,\vec{x})$.
\end{comment}

\item $\paren{\synthinvkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\koption{G}}$

This is syntax sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\boolkwd\mbox{ }\koption{G}}$.
\end{itemize}

\subsection{Declaring Sorts}
\label{ssec:declaring-sorts}

In certain logics, 
it is possible for the user to declare user-defined sorts.
For example, 
$\dtsdeclkwd$ commands may be given
when the theory of datatypes is enabled in the background
logic,
$\sortdeclkwd$ commands may be given
when uninterpreted sorts are enabled in the background logic.

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }S\mbox{ }D}$

This is syntax sugar for
$\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S\mbox{ }0} }\mbox{ }\paren{D}}$.

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S_1\mbox{ }a_1}\ldots\paren{S_n\mbox{ }a_n} }\mbox{ }\paren{D_1 \ldots D_n}}$

This command adds symbols corresponding to the datatype
definitions $D_1, \ldots, D_n$ for $S_1, \ldots, S_n$ 
to the current signature.
For each $i = 1, \ldots, n$, integer constant $a_i$ denotes the arity of 
datatype $S_i$.
The syntax of 
$D_i$ is a \emph{constructor listing} of the form
\[
\paren{
\paren{c_1\mbox{ }\paren{s_{11}\mbox{ }\sigma_{11}}\mbox{ }\ldots\mbox{ }\paren{s_{1m_1}\mbox{ }\sigma_{1m_1}} }
\mbox{ }\ldots\mbox{ }
\paren{c_k\mbox{ }\paren{s_{k1}\mbox{ }\sigma_{k1}}\mbox{ }\ldots\mbox{ }\paren{s_{km_k}\mbox{ }\sigma_{km_k}} }
}
\]
For each $i$, the following symbols are added to the signature:
\begin{enumerate}
\item 
Symbol $S_i$ is added to the current signature,
defined it as a datatype sort whose definition is given by $D_i$,
\item 
Symbols $c_1, \ldots, c_k$ are added to the signature,
where
for each $j = 1, \ldots, k$, symbol $c_j$
is defined as a \emph{constructor}
of sort $\sigma_{j1} \times \ldots \times \sigma_{jm_j} \rightarrow D_i$,
\item 
For each $j = 1, \ldots, k$, $\ell = 1, \ldots m_j$, symbol $s_{j\ell}$
is added to the signature,
defined as a \emph{selector}
of sort $D_i \rightarrow \sigma_{j\ell}$.
%For each $j = 1, \ldots, k$, 
\end{enumerate}

%\rem{Explain symbols?}
This command should be rejected if any of the above symbols this command
adds to the signature are already
a symbol in the current signature.
We provide examples of datatype definitions in \cref{sec:examples}.
For full details on well-formed datatype declarations,
refer to Section 4.2.3 of the SMT-LIB 2.6 standard~\cite{BarFT-RR-17}.

\item $\paren{\sortdeclkwd\mbox{ }S\mbox{ }n}$

This command adds the symbol $S$ to the current signature
and associates it with an uninterpreted sort of arity $n$.
This command should be rejected if $S$ is already
a symbol in the current signature.

\end{itemize}


\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }\sigma\mbox{ }t}$

This adds to the current signature
the symbol $S$ of sort $\sigma$
if $n=0$ or $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$ if $n>0$.
The variables $x_1, \ldots, x_n$ may occur freely in $t$.
It defines $S$ as a term whose semantics are given by the function
$\lambda x_1, \ldots, x_n.\, t$.
Notice that $t$ may not contain any free occurrences of $S$,
that is, the definition above is not recursive.
This command is not well-formed if $t$ is not a well-sorted
term of sort $\sigma$.
This command should be rejected if $S$ is already
a symbol in the current signature.

\item $\paren{\sortdefkwd\mbox{ }S\mbox{ }\paren{u_1 \ldots u_n}\mbox{ }\sigma}$

This adds the symbol $S$ to the current signature.
It defines $S$ as the sort $\sigma$.
The sort variables $u_1, \ldots, u_n$
may occur free in $\sigma$,
while $S$ may not occur free in $\sigma$.
This command is not well-formed if $\sigma$
is not a well-formed sort.
This command should be rejected if $S$ is already
a symbol in the current signature.

\end{itemize}

\subsection{Asserting Synthesis Constraints and Assumptions}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }t}$

This adds $t$ to the set of constraints.
This command is well formed if $t$ is a well-sorted formula,
that is, a well-sorted term of sort $\sbool$.
% constraint
%We further require that $t$ is in the logic of
Furthermore,
the term $t$ should be allowed
based on the restrictions of the current logic,
see \cref{sec:sygus-logic} for more details.

\item $\paren{\assumekwd\mbox{ }t}$

This adds $t$ to the set of assumptions.
Like constraints,
this command is well formed if $t$ is a well-sorted term of sort $\sbool$.
and is allowed based on the restrictions of the current logic.

\item $\paren{\constraintinvkwd\mbox{ }S\mbox{ }S_{pre}\mbox{ }S_{trans}\mbox{ }S_{post}}$

%This command is syntax-sugar for
%declaring a set of variables 
%and asserting a constraint corresponding to the invariant synthesis problem.
This command adds a set of constraints to the current 
state that correspond to an invariant synthesis problem for function-to-synthesize $S$,
where $S_{pre}$ denotes a pre-condition,
$S_{post}$ denotes a post-condition
and $S_{trans}$ denotes a transition relation.

A constraint of this form is well-formed if:
\begin{enumerate}
\item
$S$ is the function-to-synthesize
of sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sbool$,
\item
$S_{pre}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{pre}$,
\item
$S_{trans}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n, y_1, \ldots, y_n.\, \varphi_{trans}$, and
\item
$S_{post}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{post}$.
\end{enumerate}
where $(x_1, \ldots, x_n)$ and $(y_1, \ldots, y_n)$
are tuples of variables of sort $(\sigma_1, \ldots, \sigma_n)$ and
$\varphi_{pre}$, $\varphi_{trans}$ and $\varphi_{post}$ are formulas.
Given that this command is well-formed, given the above definitions,
this command is syntax sugar for:
\[
\begin{array}{l}
\paren{\vardeclkwd\mbox{ }v_1\mbox{ }\sigma_1}\\
\paren{\vardeclkwd\mbox{ }v'_1\mbox{ }\sigma_1}\\
\ldots\\
\paren{\vardeclkwd\mbox{ }v_n\mbox{ }\sigma_n}\\
\paren{\vardeclkwd\mbox{ }v'_n\mbox{ }\sigma_n}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S_{pre}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{{\tt and}\mbox{ }\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{trans}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}\mbox{ }
\paren{S\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{post}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\end{array}
\]
where $v_1, v'_1, \ldots, v_n, v'_n$ are fresh symbols.

\end{itemize}

\subsection{Asserting Oracle Constraints and Assumptions}
\begin{itemize}
\item $\paren{\constraintoraclekwd\mbox{ } N \mbox{ } 
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }
\paren{\paren{y_{1}\mbox{ }\tau_{1}} \ldots \paren{y_{m}\mbox{ }\tau_{m}}}  \mbox{ } t}$

This informs the solver of the existance of an external binary with name $N$
which can be used as means of adding new constraints to the problem.
This command is well-formed only if $N$
\emph{implements} a function of sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \tau_{1} \times \ldots \times \tau_{m}$
(for a definition of the expected implementation of an external binary, see Section~\ref{sec:oracleimplementations}),
and $t$ is a well-sorted term of sort $\sbool$ 
whose free symbols may include those in the current signature, as well as any symbol in $x_1 \ldots x_{n}$ and $y_1 \ldots y_{m}$,
and moreover is allowed based on the restrictions of the current logic.

Assuming this command is well-formed,
the interaction between the synthesis solver and the binary
can be understood as the solver passing \emph{constant values}\footnote{
A definition of constant value for $T$ coincides with terms generated by the
SyGuS grammar term $\paren{\constantkwd\mbox{ }T}$.
}
$c_1, \ldots, c_n$ for $x_1, \ldots x_n$ as input to the binary,
and the binary generating a list of constant values
$d_{1}, \ldots, d_{m}$ corresponding to the output $y_{1}, \ldots y_{m}$.
The expected implementation for passing
constant values as input and output 
is described in Section~\ref{sec:oracleimplementations}.
For each such call,
the formula $t[c_1 \ldots c_{n} d_1 \ldots d_m]$, i.e., 
$t$ with all occurences of $x_1, \ldots, x_{n}, y_1, \ldots, y_m$ replaced with $c_1, \ldots, c_{n}, d_1, \ldots d_m$, 
is added to the current list of constraints $\varphi$ in the conjecture.

Note that 
the synthesis solver may choose to call the binary $N$ 
any time during solving, and as many times as it chooses.
Note that it is possible that the synthesis solver may call the binary with
the same input more than once.

\item 
$\paren{\assumeoraclekwd\mbox{ } N \mbox{ } 
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }
\paren{\paren{y_{1}\mbox{ }\tau_{1}} \ldots \paren{y_{m}\mbox{ }\tau_{m}}}  \mbox{ } t}$

This command is identical to $\constraintoraclekwd$,
but the term $t[c_1 \ldots c_{n} d_1 \ldots d_m]$ obtained from a call to the external binary
is added to the set of assumptions instead of the set of constraints.

\end{itemize}

\subsection{Declaring Oracle Functional Symbols}

\begin{itemize}
\item $\paren{\oracledeckwd\mbox{ }S\mbox{ } N\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }\sigma}$

This adds to the current signature a symbol $S$ of function sort 
$\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$
whose interpretation is given by an external oracle also with name $N$. 
For every call to the oracle, an assumption about the behaviour of $S$ is added to the list of assumptions $\alpha$ in the conjecture.
Note that this command is syntactic sugar for:

\[
\begin{array}{l}
\paren{\vardeclkwd\mbox{ }S \mbox{ }\paren{\funsortkwd\mbox{ }  \sigma_1\mbox{ } \ldots\mbox{ } \sigma_n\mbox{ } \mbox{ }\sigma}}\\
\paren{\assumeoraclekwd\mbox{ } N \mbox{ } 
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }
\paren{\paren{x \mbox{ }\sigma}}  \mbox{ } 
\paren{{\tt=}\mbox{ } \paren{S \mbox{ } x_1 \mbox{ } \ldots \mbox{ } x_n}\mbox{ } x}
}
\end{array}
\]
\end{itemize}
% The solver can call $S$ as many times as is necessary, and for every input on which $S$ has not been called, $S$ is treated as a universally quantified uninterpreted function. For more details see Section~\ref{sec:correctness-oracles}.


\subsection{Pre-defined Oracle Types}
Given a synthesis function symbol $F$ in the current signature
with sort $\sigma_1, \ldots \sigma_n \rightarrow \sigma$, each of the following commands 
is used to declare an external oracle with name $N$, which generate specific types of oracle constraints and assumptions over the behaviour of $F$. 

\begin{itemize}
\item $\paren{\iooracledeckwd\mbox{ }N\mbox{ } F}$

This declares an input-output oracle for function $F$. 
It is syntactic sugar for:


$\paren{\constraintoraclekwd\mbox{ } N\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }
\paren{\paren{x \mbox{ }\sigma}}
\paren{{\tt=}\mbox{ } \paren{F \mbox{ } x_1 \ldots x_n}\mbox{ }  x}
}
$


\item$\paren{\poswitnessoracledeckwd\mbox{ }N\mbox{ } F} $

This declares a positive witness oracle for synthesis function $F$ and is syntactic sugar for:

$\paren{\constraintoraclekwd\mbox{ } N\mbox{ }
\paren{}\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} \paren{x \mbox{ }\sigma}}\mbox{ }
\paren{{\tt=}\mbox{ } \paren{F \mbox{ } x_1 \ldots x_n}\mbox{ }  x}
}
$

\item$\paren{\negwitnessoracledeckwd\mbox{ }N\mbox{ } F}$

This declares a negative witness oracle for synthesis function $F$ and  is syntactic sugar for:

% $\paren{\oracledeckwd\mbox{ }S\mbox{ }
% \paren{}
% \paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} \paren{x \mbox{ }\sigma}}\mbox{ }
% }$

$\paren{\constraintoraclekwd\mbox{ } N\mbox{ }
\paren{}\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} \paren{x \mbox{ }\sigma}}\mbox{ }
\paren{{\tt not} \mbox{ } \paren{{\tt=} \mbox{ } \paren{F \mbox{ } x_1 \ldots x_n}\mbox{ }  x}}}
$


\item$\paren{\memoracledeckwd\mbox{ }N\mbox{ } F} $

This declares a membership-query oracle for synthesis function $F$ and is syntactic sugar for:


$\paren{\constraintoraclekwd \mbox{ } N\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} \paren{x \mbox{ }\sigma}}\mbox{ }
\paren{\paren{R \mbox{ } \sbool}}\mbox{ } 
%
\paren{{\tt=} \mbox{ } \paren{{\tt=}\mbox{ } \paren{F \mbox{ } x_1 \ldots x_n } \mbox{ }  x} \mbox{ } R}}
$

% 

\item$\paren{\cexoracledeckwd\mbox{ }N\mbox{ } F} $

This declares a counter-example oracle for synthesis function $F$ and is syntactic sugar for:

$\paren{\constraintoraclekwd\mbox{ } N\mbox{ }
\paren{\paren{F_c \mbox{ } \paren{\funsortkwd \mbox{ } \sigma_1 \mbox{ } \ldots \mbox{ } \sigma_n \mbox{ } \sigma}}}
\paren{\paren{R \mbox{ } \sbool} \paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} } \\
\paren{\implopkwd \mbox{ } R  \mbox{ } \paren{{\tt not} \paren{{\tt=}\mbox{ } \paren{F \mbox{ } x_1 \ldots x_n} \mbox{ } \paren{F_c \mbox{ }x_1 \ldots x_n }}}}}
$

where $F_c$ is a candidate implementation for $F$, and $R$ is a boolean that indicates that the oracle was able to find a counterexample.


\item$\paren{\corroracledeckwd\mbox{ }S\mbox{ }N\mbox{ } F} $

This declares a correctness oracle, and adds associated function oracle symbol $S$ to the signature, that determines whether a candidate implementation of a synthesis function $F$,
where $F$ is a synthesis function symbol in the current signature
with sort $\sigma_1, \ldots \sigma_n \rightarrow \sigma$, is correct. 


This oracle is mandatory to call in order to determine correctness of the synthesis function and so it is syntactic sugar for:

$\paren{\oracledeckwd\mbox{ }S\mbox{ }N\mbox{ }\paren{\paren{
x_1\mbox{ }
\paren{
\funsortkwd \mbox{ } \sigma_1 \ldots \sigma_n\mbox{ }\sigma }}}
\sbool}\\
%
\paren{\constraintkwd \mbox{ } \paren{S \mbox{ } F}}
$


\item$\paren{\corrcexoracledeckwd\mbox{ }S\mbox{ }N\mbox{ } F\mbox{ }} $
This declares a correctness oracle, and adds associated functional oracle symbol $S$ to the signature, that determines whether a candidate implementation of a synthesis function $F$,
where $F$ is a synthesis function symbol in the current signature
with sort $\sigma_1, \ldots \sigma_n \rightarrow \sigma$, is correct and returns a counterexample if not.

This oracle is mandatory to call to determine correctness of a synthesis function, and it adds a constraint to the oracle constraints, so it is syntactic sugar for the following commands:

$
\paren{\constraintoraclekwd\mbox{ } N\mbox{ }
\paren{\paren{F_c \mbox{ } \paren{\funsortkwd \mbox{ } \sigma_1 \mbox{ } \ldots \mbox{ } \sigma_n \mbox{ } \sigma}}}
\paren{\paren{R \mbox{ } \sbool} \paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} } \\
\paren{\implopkwd R  \mbox{ } \paren{{\tt not} \paren{{\tt=}\mbox{ } \paren{F \mbox{ } x_1 \ldots x_n} \mbox{ } \paren{F_c \mbox{ }x_1 \ldots x_n }}}}} \\
$

$
\paren{\oracledeckwd\mbox{ }S\mbox{ }N\mbox{ }\paren{\paren{
x_1\mbox{ }
\paren{
\funsortkwd \mbox{ } \sigma_1 \ldots \sigma_n\mbox{ }\sigma }}}
\sbool}\\
%
\paren{\constraintkwd \mbox{ } \paren{S \mbox{ } F}}
$



% \item$\paren{\dioracledeckwd\mbox{ }S\mbox{ } F\mbox{ }} $



\end{itemize}	


\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$

This asks the synthesis solver to find a solution for the synthesis conjecture
corresponding to the current list of functions-to-synthesize,
universal variables and constraints.
The expected output
from the synthesis solver is covered in \cref{sec:output}.
\end{itemize}

\subsection{Setting Benchmark Information}

\begin{itemize}
\item $\paren{\setinfokwd\mbox{ }:S\mbox{ }L}$

This sets meta-information specified by the symbol $S$
to the (literal) value $L$, whose syntax is given in \cref{ssec:literals}.
This has no impact on the state, and is used to annotate the
benchmark with relevant information.
For the purposes of this document, we define the meaning of
the concrete symbol, ${\tt sygus\mbox{-}version}$,
which when passed to this command is used to indicate the version of the SyGuS
format used in the benchmark.
A benchmark whose header contains the line
\[
\paren{\setinfokwd\mbox{ }:{\tt sygus\mbox{-}version\mbox{ }2.0}}
\]
will use the version 2.0 syntax as specified by this document,
whereas a value of $1.0$ indicates that the benchmark will use the
syntax in the previous SyGuS format~\cite{sygusFormat,sygusSyntax2015,sygusSyntax2016}.
\end{itemize}
\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }:S\mbox{ }L}$

This sets the solver-specific option specified by the symbol $S$ 
to the (literal) value $L$, whose syntax is given in \cref{ssec:literals}.
We do not give concrete examples of such options in this document. %\rem{Any needed?}
It is recommended that synthesis solvers
ignore unrecognized options, 
and choose reasonable defaults when the
options are left unspecified.
\end{itemize}

\section{Synthesis Solver Output}
\label{sec:output}

This section covers the expected output from a synthesis solver,
which currently is limited to responses to $\checksynthkwd$ 
only.

\begin{itemize}
\item
A well-formed response to $\checksynthkwd$ is one of the following:

\begin{enumerate}
\item
A list of commands of the form:
\[
\begin{array}{l}
\paren{\fundefcmdkwd\mbox{ }f_{1}\mbox{ }X_{1}\mbox{ }\sigma_{1}\mbox{ }t_{1}}\\
\ldots\\
\paren{\fundefcmdkwd\mbox{ }f_{n}\mbox{ }X_{n}\mbox{ }\sigma_{n}\mbox{ }t_{n}}
\end{array}
\]
where functions $f_{1}, \ldots, f_{n}$
are the functions-to-synthesize in the current state,
%\rem{Probably should be in order declared, 
%or otherwise would have to enforce dependent definitions are ordered properly}, 
$X_{1}, \ldots, X_{n}$ are sorted variable lists,
$\sigma_{1}, \ldots, \sigma_{n}$ are types,
and $t_{1}, \ldots, t_{n}$ are terms.
The syntax $\fundefcmdkwd$ can be either $\fundefkwd$ or $\recfundefkwd$.
The latter must be used for $f_i$ if it occurs free in $t_i$,
that is, when the definition of $f_i$ is recursive.
It is required that $f_1, \ldots, f_n$ be
provided in the order in which they were declared.\footnote{
This is to ensure that the definition of $f_i$, which may depend on a definition
of $f_j$ for $j<i$, is given in the correct order.
}
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{j}$ is a term of $\sigma_{j}$,
and $X_{j}$ is identical to the sorted variable list
used when introducing the function-to-synthesize $f_{j}$.

\item
The output ${\tt infeasible}$,
indicating that the conjecture has no solutions.

\item
The output ${\tt fail}$,
indicating that the solver failed to find a solution to the conjecture.

\end{enumerate}

A response to $\checksynthkwd$ of the first kind is a correct solution if
it satisfies both the semantic and syntactic restrictions given by
the current state.
We describe this in more detail in \cref{sec:logical-semantics}.

We do not define the correctness of an ${\tt infeasible}$ response 
in this document. 
We remark that a response of this form should be given
by a solver only if it is certain that a solution to the current
conjecture does not exist.
A conjecture may be infeasible based on the current semantic
restrictions, or may be infeasible due to a combination
of semantic restrictions and the syntactic ones imposed on functions-to-synthesize.
The response ${\tt fail}$ indicates that the solver
was unable to find a solution, which does not necessarily imply that
the conjecture is infeasible.

\end{itemize}

%\section{

\section{SyGuS Background Logics}
\label{sec:sygus-logic}

In this section,
we describe how the background logic
restricts the constraints and grammars that are allowed as inputs.
%As mentioned in \cref{ssec:set-logic},
%a SyGuS input may be given a background logic
%specified by a symbol $S$,
%where $S$ may be a standard SMT-LIB logic
%or may be solver-specific.
%We refer to $S$ as the \emph{base logic}
%of a SyGuS input.
A SyGuS background logic consists of three parts:
\begin{enumerate}
\item An \emph{input logic}, which can be set as part of a $\setlogickwd$ command.
This corresponds to a SMT-LIB standard logic or may be solver specific.
The input logic determines the set of terms that are allowed in 
constraints.

\item An \emph{output logic}, which can be set as part of a $\setlogickwd$ command.
Like input logics, this
can correspond to an SMT-LIB standard logic or may be solver specific.
The output logic determines the set of terms that are allowed in
grammars and solutions.

\item A \emph{feature set}, 
which restricts or extends the set of commands that are allowed in a SyGuS input,
and may further refine the constraints, grammars and solutions allowed by the logic.
Generally, feature sets are not expressible in an input or output logic
and are independent of them.
\end{enumerate}
%We give more detail on what consistutes an extended logic in the following.
We refer to input and output logics as \emph{base} logics.
Base logics have the same scope as SMT-LIB logics, in that their purpose is to
define a set of terms and formulas.
Further extensions and restrictions of the SyGuS language are recommended
to be expressed as new base logics whenever it is possible to do so.
On the other hand,
the feature set is allowed to restrict or extend the
\emph{commands} that are allowed in the input
or specific relationships between how terms appear in commands,
which is not expressible in a base logic.
%It is recommended that new base logics are defined for
%extensions and restrictions of the SyGuS language when it is possible to do so.

The default SyGuS logic is the one
whose input and output logics include only the core theory of Booleans,
and whose feature set enables grammars and the core commands of the language.
We describe logics and feature sets
in more detail in \cref{ssec:smt-logic,ssec:feature-sets}.
A formal definition of how these
restrict the set of terms that may appear 
in constraints and grammars
is then given in \cref{ssec:logicr-constraints,ssec:logicr-grammars}.
%We give three such examples in \cref{ssec:logicr-grammars}
%below.
%\rem{Standard extension to base logic + extensions?}
%This section pertains only to 

\subsection{Input and Output Logics}
\label{ssec:smt-logic}

%This section covers only base logics defined in the SMT-LIB standard.
SMT-LIB provides a catalog of standard logics,
available at \url{www.smt-lib.org}.
SyGuS logics may use any of these logics
either as input logics or as output logics.
For many applications,
the input and output logic is expected to be the same, although
no relationship between the two is required.

At a high level, a \emph{logic} includes a set of theories
and defines a subset of terms constructible in the signature of those theories
that belong to it.
If a logic includes a theory, then its symbols are added
to the current signature when a $\setlogickwd$ command is issued.
Further details on the formal definition of 
theory and logic declarations can be found in Sections 3.7 and 3.8
of the SMT-LIB 2.6 standard~\cite{BarFT-RR-17}.
We briefly review some of the important logics and theories in the following.
More concrete details on
standard SMT-LIB logics can be found in the reference
grammars in \cref{apx:ref-grammars}.

The input and output logic components of the default SyGuS logic include only the
\emph{core theory}.
The signature of the core theory 
has the Boolean sort ${\tt Bool}$,
the Boolean constants ${\tt true}$ and ${\tt false}$, the
usual logical Boolean connectives 
${\tt not}$, ${\tt and}$, ${\tt or}$, implication ${\tt =>}$, ${\tt xor}$,
and the parametric symbols ${\tt =}$ and ${\tt ite}$
denoting equality and if-then-else terms for all sorts in the signature.
%that is, no restrictions are placed on the set of terms that may 
%appear, nor are any symbols predefined.
Logics that include the theories mentioned in this section supplement the signature
of the current state with additional sorts and symbols of that theory.

\paragraph{Arithmetic}
The theory of integers is enabled 
in logics like linear integer arithmetic ${\tt LIA}$
or non-linear integer arithmetic ${\tt NIA}$.
The signature of this theory includes the integer sort ${\tt Int}$ and
typical function symbols of arithmetic, including
addition ${\tt +}$
and multiplication ${\tt *}$.
Unary negation and subtraction are specified by ${\tt -}$.
Constants of the theory are integer constants.
Positive integers and zero are specified by the syntax $\intconst$ from \cref{ssec:literals},
whereas negative integers are specified as the unary negation of positive integer,
that is, ${\tt (-\ 2)}$ denotes negative two.
Analogously, 
the theory of reals is enabled
in logics like linear real arithmetic ${\tt LRA}$
or non-linear real arithmetic ${\tt NRA}$.
Its signature includes the real sort ${\tt Real}$.
Some of the function symbols of arithmetic are syntactically identical to
those from the theory of integers, including
${\tt +}$, ${\tt -}$ and ${\tt *}$.
The signature of the theory of reals additionally includes
real division ${\tt /}$.
Positive reals and zero in this theory can either be specified as
decimals using the syntax $\realconst$
or as rationals of the form ${\tt (/\ m\ n)}$,
where ${\tt m}$ and ${\tt n}$ are numerals.
Negative reals are specified as the unary negation of a decimal
or as a negative rational ${\tt (/\ (-\ m)\ n)}$.

\paragraph{Bit-Vectors}
The theory of fixed-width bit-vectors
is included in logics specified 
by symbols that include the substring ${\tt BV}$.
The signature of this theory includes a family of 
indexed sorts ${\tt (\_\ BitVec\ n)}$
denoting bit-vectors of width $n$.
The functions in this signature include various operations on bit-vectors,
including bit-wise, arithmetic, and shifting operations.

\paragraph{Strings}
The theory of (unbounded) unicode strings and regular expressions
is included in some logics specified with ${\tt S}$ as a prefix,
such as ${\tt S}$ (strings) or ${\tt SLIA}$ (strings
with linear integer arithmetic).
The string of this theory includes the string sort ${\tt String}$,
interpreted as the set of all unicode strings.
Functions in this signature include string concatenation ${\tt str.++}$,
string length ${\tt str.len}$ as well as many extended functions
such as string containment ${\tt str.contains}$,
string search ${\tt str.indexof}$ which returns the index of
a string in another, and so on.
A full description of this theory is given in a proposal to SMT-LIB~\cite{smtlibStrings}.

\paragraph{Arrays}
The theory of arrays is included in logics specified with ${\tt A}$ as a prefix,
such as ${\tt ABV}$ or ${\tt ALIA}$.
The signature of this theory includes a parametric sort ${\tt Array}$
of arity two, whose sort parameters
indicate the index type and the element type of the array.
It has two function symbols, ${\tt select}$ and ${\tt store}$,
interpreted as array select and array store.

\paragraph{Datatypes}
The theory of datatypes
is included in logics specified 
by symbols that include the substring ${\tt DT}$.
Logics that include datatypes are such that
$\dtsdeclkwd$ commands are permitted in inputs, 
whereas all others do not.
The signature of the theory of datatypes
is largely determined by the concrete datatypes definitions provided
by the user.
As mentioned in \cref{ssec:declaring-sorts}, these commands append datatype sorts, 
constructors and selectors to the current signature.
Constructor symbols are used for constructing
values (e.g. ${\tt cons}$ constructs a list from an element and another list),
and selectors access subfields (e.g. ${\tt tail}$ returns its second argument).
Notice that the value of \emph{wrongly applied} selectors, e.g. ${\tt tail}$ applied
to the ${\tt nil}$ list, is underspecified and hence freely interpreted
in models of this theory.
The only fixed symbol in the theory of datatypes is the unary
indexed \emph{discriminator} predicate ${\tt(\_\ is\ C)}$,
which holds if and only if its argument is an application of constructor $C$.
For example, assuming the standard definition of a list datatype
with constructors ${\tt cons}$ and ${\tt nil}$,
we have that ${\tt ((\_\ is\ nil)\ x)}$ holds if and only if
$x$ is the ${\tt nil}$ list.

\paragraph{Uninterpreted Functions}
In SMT-LIB, uninterpreted functions and sorts may be declared in
logics that include the substring ${\tt UF}$,
whose interpretations are not fixed.
Declarations for functions and sorts are made via SMT-LIB commands 
$\fundeclkwd$ and $\sortdeclkwd$ respectively.
In the SyGuS language, we do not permit
the declaration of functions with $\fundeclkwd$ command.
Instead, the language includes only the latter command.
Thus, the only effect that specifying ${\tt UF}$ in the logic string has is
that user-defined sorts may be declared via $\sortdeclkwd$, where
variables and functions-to-synthesize may involve these sorts in the usual way.
We remark here that
encoding synthesis problems 
that involve (existentially quantified)
uninterpreted functions
can be represented by declaring those functions
using $\synthfunkwd$ commands where no grammar is provided.
Synthesis problems that involve universally quantified variables of function sort
are planned to be addressed in a future revision of this document
that includes concrete syntax for function sorts.

\subsubsection{Other Theories}

Many other theories
are possible beyond those supported in the SMT-LIB standard.
In this section, we mention theories that are of interest to synthesis applications
that are not included in the SMT-LIB standard.

\paragraph{Tables}
TODO

\subsection{Features and Feature Sets}
\label{ssec:feature-sets}

A feature set is a set of values, called \emph{features},
which for the purposes of this document can be seen as an enumeration type.
Their syntax is given in \cref{ssec:syntax-features}.
The meaning of all features standardized by this document are listed below.
\begin{itemize}
\item $\fgrammarskwd$: if enabled, 
then grammars may be provided for functions-to-synthesize 
in $\synthfunkwd$ commands.
\item $\ffwddeclskwd$: if enabled,
grammars of $\synthfunkwd$ may refer to previously declared synthesis functions,
called \emph{forward declarations}.
\item $\frecursionkwd$: if enabled,
grammars of $\synthfunkwd$ can generate terms that correspond to recursive definitions.
\item $\foracleskwd$: if enabled,
commands from $\oraclecmd$ are permitted.
%\item $\fquantifierskwd$: if enabled,
%arbitrary quantification is allowed in constraints.
\end{itemize}
Formal definition of these features are given within the 
\cref{ssec:logicr-constraints,ssec:logicr-grammars}.
Other features and their meanings may be solver specific, 
which are not covered here.

The feature set component of the default SyGuS logic is the set $\{ \fgrammarskwd \}$.
In other words, grammars may be provided, but those involving
forward declarations and recursion are not permitted by default.

\subsection{SyGuS Logic Restrictions on Constraints}
\label{ssec:logicr-constraints}

%For the former,
%we follow the same conventions as SMT-LIB
%if $S$ is a standard SMT-LIB logic.
%For the latter,
%we give details on the default settings of the logic
%with respect to restrictions on terms that may appear in grammars
%in \cref{sec:sygus-logic}.

%This section defines restrictions on the terms $t$
%that can appear in commands of the form $\paren{\constraintkwd\mbox{ }t}$.
Let $\slogic$ be a SyGuS logic whose input logic
is one from the SMT-LIB standard, or an externally defined logic.
A term $t$ is not allowed by $\slogic$ 
to be an argument to a $\constraintkwd$ command 
if it is not allowed by the \emph{input} logic of $\slogic$, 
according to the definition of that logic.
%Exceptions to this rule are described here.

%By convention, as stated in \cref{ssec:set-logic}, 
%the base logic specified
%by a $\setlogickwd$ in a SyGuS file must allow quantifiers.
%%This is due to the fact that
%%the synthesis conjecture implicit in the state
%%contains universal quantification on the universal variables of our state.
%However,
%constraints \emph{cannot} themselves contain 
%formulas with quantifiers
%unless the feature $\fquantifierskwd$ is enabled in the background logic.

%\rem{Reference extension?}

\subsection{SyGuS Logic Restrictions on Grammars}
\label{ssec:logicr-grammars}

%This section defines restrictions on the terms
%that may appear in grammars.
%The base logic affects the kinds of grammars that
%are allowed in SyGuS inputs.
Let $\slogic$ be a SyGuS logic whose output logic
is one from the SMT-LIB standard.
A grammar $G$ is not allowed by $\slogic$ if
it generates some term $t$ with 
no free occurrences of non-terminal
symbols that is not allowed by the \emph{output} logic of $\slogic$,
according to the definition of that logic. % in the SMT-LIB standard.
%For instance, 
%this restriction disallows grammars
%in the logic of \emph{linear} integer arithmetic
%for which it is possible to generate a term involving
%the multiplication of two non-constant integer terms.

Notice that it may be the case that a grammar $G$
contains a rule whose conclusion is a term 
that does not itself meet the restrictions 
of the output logic.
For example, consider the logic of \emph{linear} integer arithmetic
and a grammar $G$ containing a non-terminal symbol $y_c$ of integer type
such that $G$ generates only constants from $y_c$.
Grammar $G$ may be allowed in the logic of linear integer arithmetic
even if it has a rule whose conclusion is $y_c * t$, 
noting that no non-linear terms can be generated from this rule,
provided that no non-linear terms can be generated from $t$.
An example demonstrating this case is given in \cref{sec:examples}.
%then the term $y_c * y$ may be the conclusion
%grammar terms $g_{ij}$ may involve
%the multiplication of two non-constant integer terms $t_1$ and $t_2$
%e.g. in the case there one of $t_i$ is a non-terminal symbol $y$
%for which $G$ generates only constant integer terms from $y$.

%The default logic assumed by the SyGuS standard assumes
%additional restrictions on the terms that are generated by grammars.
The feature set component of the SyGuS logic 
imposes additional restrictions
on the terms that are generated by grammars.
Note the following definition.
The \emph{expanded form} of a term $t$
is the (unique) term obtained
by replacing all functions $f$ in $t$ that are defined as macros
%in the current signature
with their corresponding definition until a fixed point is reached.
A grammar $G$ for function-to-synthesize $f$ is not allowed by a SyGuS logic $\slogic$
if $G$  contains a rule whose conclusion is a term $t$
whose expanded form contains applications of functions-to-synthesize
unless the feature $\ffwddeclskwd$ is enabled in the feature set of $\slogic$;
it is not allowed if $t$ 
contains $f$ itself unless the feature $\frecursionkwd$ is enabled in the feature set of $\slogic$;
it is not allowed regardless of the terms it generates unless $\fgrammarskwd$ is enabled in the feature set of $\slogic$.


\subsection{Additional SyGuS Logics}
%\rem{Special logics: PBE, single invariant synthesis?}
Here, we cover additional SyGuS logics that are standardized
by this document that are \emph{not} defined by the SMT-LIB standard.

\paragraph{Programming-by-examples (PBE)}
Given an SMT-LIB standard logic $X$ 
that does not contain the prefix ${\tt QF\_}$,
the base logic ${\tt PBE\_}X$ denotes the logic
where constraints are limited to (conjunctions of)
equalities whose left hand side is a term $f( \vec c )$ and 
whose right hand side is $d$,
where $f$ is a function
and $\vec c$, $d$ are constants.
We refer to an equality of this form as a \emph{PBE equality}.
Such equalities denote a relationship between the inputs and output of 
function $f$ for a single point.
Notice that formulas allowed by 
logic ${\tt PBE\_}X$ are a subset of those allowed by ${\tt QF\_}X$.

We use the logic string ${\tt PBE\_}X$ to refer to a SyGuS logic as well.
Given an SMT-LIB standard logic $X$
that does not contain the prefix ${\tt QF\_}$,
the SyGuS logic ${\tt PBE\_}X$ is the one
whose input logic is ${\tt PBE\_}X$,
whose output logic ${\tt QF\_}X$,
and whose feature set is the default one.
In other words, the constraints allowed by this logic
are limited to conjunctions of PBE equalities,
but gives no special restrictions
on the solutions or grammars that can be provided.

By construction of the overall synthesis conjecture, a SyGuS command sequence
meets the requirements of the input logic ${\tt PBE\_}X$
if and only if each ${\tt constraint}$ command takes as argument a PBE equality.

\paragraph{Single Invariant-to-Synthesize (Inv)}
Given an SMT-LIB standard logic $X$,
the base logic ${\tt Inv\_}X$ denotes the logic
where formulas are limited to the invariant synthesis
problem for a single invariant-to-synthesize.
Concretely,
this means that formulas are limited to those that 
are (syntactically) a conjunction of three implications, 
for a single predicate symbol $I$:
\begin{enumerate}
\item The first is an implication whose antecedent (the pre-condition) 
is an arbitrary formula
in the logic $X$ and
and whose conclusion is
an application $I( \vec x )$ where $\vec x$ is a tuple of unique variables,

\item The second is an implication whose antecedent is
$I( \vec x ) \wedge \varphi$
where $\vec x$ is a tuple of unique variables and $\varphi$ (the transition relation) 
is an arbitrary formula
in the logic $X$,
and whose conclusion is $I( \vec y )$
where $\vec y$ is a tuple of unique variables disjoint from $\vec x$,

\item The third is an implication whose antecedent is 
an application $I( \vec x )$ where $\vec x$ is a tuple of unique variables,
and whose conclusion (the post-condition) is an arbitrary formula in the logic $X$.
\end{enumerate}
The variables $\vec x$ in each of these three formulas are not required to be the same.

Like the previous section, 
we use the logic string ${\tt Inv\_}X$ to refer to SyGuS logics as well.
Given an SMT-LIB standard logic $X$
that does not contain the prefix ${\tt QF\_}$,
logic ${\tt Inv\_}X$ denotes the SyGuS logic
whose input logic is ${\tt Inv\_QF\_}X$,
whose output logic is ${\tt QF\_}X$,
and whose feature set is the default one.

Note that if a SyGuS command sequence is such that
(1) it contains one $\synthinvkwd$ command,
(2) it contains one $\constraintinvkwd$ command whose arguments are predicates whose definitions belong to logic $X$,
and (3) it contains no other commands that introduce constraints,
then its constraints are guaranteed to meet the requirements of the input logic ${\tt Inv\_}X$.



\section{Formal Semantics}
\label{sec:logical-semantics}

Here we give the formal semantics
for what constitutes a correct solution for a synthesis conjecture.

\subsection{Satisfying Syntactic Specifications}
\label{ssec:sat-syntactic}

In this section,
we formalize the notion of satisfying the \emph{syntactic specification}
of the synthesis conjecture.

As described in \cref{ssec:dec-synth-fun},
a grammar $G$ is specified as a predeclaration and
a \emph{grouped rule listing} of the form
\[
\paren{\paren{y_1\mbox{ }\tau_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots 
\paren{y_n\mbox{ }\tau_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}
\]
where $y_1, \ldots, y_n$ are variables
and $g_{11} \ldots g_{1m_1}, \ldots, g_{n1} \ldots g_{nm_n}$
are grammar terms.
We associate each grammar with a sorted variable list $X$,
namely the argument list of the function-to-synthesize.
We refer to $y_1$ as the \emph{start symbol} of $G$.

We interpret $G$ as a (possibly infinite) set of rules 
of the form $y \mapsto t$ where $t$ is an (ordinary) term
based on the following definition.
For each $y_i, g_{ik}$ in the grouped rule list,
if $g_{ik}$ is $\paren{\constantkwd\mbox{ }\sigma_c}$,
then $G$ contains the rule $y_i \mapsto c$ for all constants of sort $\sigma_c$.
If $g_{ik}$ is $\paren{\varkwd\mbox{ }\sigma_v}$,
then $G$ contains the rule $y_i \mapsto x$
for all variables $x \in X$ of sort $\sigma_v$.
Otherwise, if $g_{ik}$ is an ordinary term,
then $G$ contains the rule $y_i \mapsto g_{ik}$.

We say that $G$ \emph{generates} term $r$ from $s$
if it is possible to construct a sequence of terms
$s_1, \ldots, s_n$
with $s_1 = s$ and $s_n = r$
where for each $1 \leq i \leq n$, term $s_i$ is obtained from $s_{i-1}$ by
replacing an occurrence of some $y$ by $t$
where $y \mapsto t$ is a rule in $G$.

Let $f$ be a function to synthesize.
A term $\lambda X.\, t$
satisfies the syntactic specification for $f$
if one of the following hold:
\begin{enumerate}
\item 
A grammar $G$ is provided for $f$,
$t$ contains no free occurrences of non-terminal symbols,
and $G$ generates $t$ starting from $y_1$,
where $y_1$ is the start symbol of $G$.

\item
No grammar is provided for $f$, and $t$ is any
term allowed in the output logic whose sort
is the same as the return sort of $f$.
\end{enumerate}
%\rem{More}
%whose variable lists are $X_1, \ldots, X_n$
%and whose grammars are $G_1, \ldots, G_n$.

Furthermore,
A tuple of functions 
$( \lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n )$
satisfies the syntactic restrictions
for functions-to-synthesize $( f_1, \ldots, f_n )$
in conjecture $\exists f_1, \ldots, f_n.\,\Psi$
if $\lambda X_i.\, t_i$
satisfies the syntactic specification for $f_i$
for each $i=1,\ldots,n$.
%\end{def}

\subsection{Satisfying Semantic Specifications}
\label{ssec:sat-semantic}

In this section,
we formalize the notion of satisfying the \emph{semantic specification}
of the synthesis conjecture
for background theories $T$ from the SMT-LIB standard.
The notion of satisfying semantic restrictions for background theories
that are not standardized in the SMT-LIB standard are not covered by this document.

A tuple of functions 
$( \lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n)$
satisfies the semantic restrictions
for functions-to-synthesize $( f_1, \ldots, f_n )$
in conjecture $\exists f_1, \ldots, f_n.\,\Psi$ in background theory $T$
if $\Psi$ is $T$-valid formula
when $f_1, \ldots, f_n$ are defined to be terms
whose semantics are given by the functions
$\lambda X_1.\, t_1, \ldots, \lambda X_n.\, t_n$.
%where $\psi$ is the formula
%$\varphi \{ f_1 \mapsto \lambda X_1.\, t_1, \ldots, f_n \mapsto \lambda X_n.\, t_n \}$
%after beta-reduction.
The formal definition for $T$-valid here
corresponds to the definition given by SMT-LIB,
for details see Section 5 of~\cite{BarFT-RR-17}.

The above definition covers cases where $f_1, \ldots, f_n$
have recursive definitions or references to forward declarations.
The formal definition of $T$-valid formulas that contain these kinds of
function definitions assumes the semantics for SMT-LIB input formulas that 
involve (defined) macros and recursive functions.

\section{Calling Oracles}
\label{sec:oracleimplementations}

In the following, we formalize the interface between the
synthesis solver and an external binary, which we call an \emph{oracle}.
The synthesis solver can query an oracle using text files with the extension
\textit{.oracle}.
The expected interface is given by the following definition.

\begin{definition}
An oracle \emph{implements an interface} with input
$(\sigma_1 \times \ldots \times \sigma_n)$ and output
$(\tau_1 \times \ldots \times \tau_m)$ if
it has the following behavior.
Let \textit{textfile.oracle}
be a file containing the text
\[
\paren{v_1 \ldots v_n}
\]
where $v_1, \ldots, v_n$ are values\footnote{
A \emph{value} of type $T$ 
coincides with a term generated by the SyGuS grammar term
$\paren{\constantkwd\mbox{ }T}$.
For example, the values of type ${\tt Int}$
have syntax ${\tt N}$ or ${\tt (- N)}$ where ${\tt N}$ is a numeral.
The values for function types include all closed lambda terms.
} of sorts $\sigma_1, \ldots, \sigma_n$
written using the syntax for values described in this document.
Let ${\tt oracle}$ be the name of the binary corresponding to the oracle.
When the oracle is executed with the command
${\tt oracle textfile.oracle}$,
it returns the text on the standard output channel
\[
\paren{w_{1} \ldots w_{m}}
\]
where $w_1, \ldots, w_n$ are values of sorts $\tau_1, \ldots, \tau_m$
written using the syntax for values described in this document.
\qed
\end{definition}

In other words, the synthesis solver and the external binary
communicate with one another using a text interface, where the input text contains
a tuple of values corresponding to input to the binary, and the output
from the binary is a tuple of terms indicating the output of the binary,
which is printed on the standard output channel.
It is expected that the synthesis solver parses these values to
ascertain the result of the query.

It is important to note that the text file
${\tt textfile.oracle}$ in the definition above is expected to take
a tuple of values only.
In some cases, 
the syntax for those values may involve symbols that are user-defined.
As an example, consider an oracle
implementing an interface whose input takes a user-defined datatype.
The definition of that datatype is \emph{not} provided as a preamble
to the given tuple of values.
This means that an external binary is responsible for being able to
parse the given text file, even when it uses symbols that
are not self-contained in that text file. 
This is a reasonable assumption,
considering that the user is providing both the oracle specification
and the binary.

The oracle accepts the name of the text file as the first command line
argument. An oracle may optionally take additional command line
arguments which are not standardized in this document.

It is the responsibility of the user to specify oracles in
SyGuS commands that implement interfaces of the appropriate sorts.
If this is not the case, the synthesis solver may choose to ignore the output
of the oracle or terminate with an error.

\subsection{Oracle Example}

\noindent Consider an oracle that implements the interface declared with the following command:\\\\
$\paren{\constraintoraclekwd\mbox{ } N \mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }
\paren{\paren{y_{1}\mbox{ }\tau_{1}} \ldots \paren{y_{m}\mbox{ }\tau_{m}}}  \mbox{ } t}$ \\

The text file must contain a list of values $\paren{v_1 \ldots v_n}$ for the input parameters $x_1 \ldots x_n$, and $v_i$ must have the same sort as $\sigma_i$.
The oracle will return a list of values $\paren{w_{1} \ldots w_{m}}$, corresponding to the output parameters $y_{1} \ldots y_{m}$, and $w_i$ must have the same sort as $\tau_i$.
%
The solver calls the oracle with the command ${\tt N \,\,textfile.oracle}$, where ${\tt N}$ is the name of the oracle implememtation as specified in the oracle constraint declaration.


\section{Examples}
\label{sec:examples}

%\rem{Simple LIA example}

\begin{example}[Linear Arithmetic with Constant Coefficients]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(synth-fun f ((x Int) (y Int)) Int
   ((I Int) (Ic Int))
   ((I Int (0 1 x y
            (+ I I)
            (* Ic I)))
    (Ic Int (0 1 2 (- 1) (- 2)))))
(declare-var x Int)
(declare-var y Int)
(constraint (= (f x y) (* 2 (+ x y))))
(check-synth)
\end{lstlisting}
In this example, the logic is set 
to linear integer arithmetic.
The grammar of the function-to-synthesize $f$
has two non-terminals, ${\tt I}$ and ${\tt Ic}$.
What is notable in this example is that
the grammar for $f$ includes a rule for ${\tt I}$ whose right hand side 
is the term ${\tt(*\ Ic\ I)}$. 
If a term of this form were to appear
in a constraint, 
then it would not be allowed since it is the
multiplication of two non-constant terms and thus is not allowed by the input logic ${\tt LIA}$.
However, 
by the definition of our restrictions on grammars in \cref{ssec:logicr-grammars},
this grammar \emph{is allowed},
since all closed terms that the grammar generates are allowed by linear arithmetic.
A possible correct solution to this synthesis conjecture is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x Int) (y Int)) Int (+ (* 2 x) (* 2 y)))
\end{lstlisting}
\end{example}

\begin{example}[Datatypes with Linear Arithmetic]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic DTLIA)
(declare-datatypes ((List 0)) (((nil) (cons (head Int) (tail List)))))
(synth-fun f ((x List)) Int
   ((I Int) (L List) (B Bool))
   ((I Int (0 1 
            (head L) 
            (+ I I)
            (ite B I I)))
    (L List (nil x (cons I L) (tail L)))
    (B Bool (((_ is nil) L) 
             ((_ is cons) L)
             (= I I)
             (>= I I)))))
(constraint (= (f (cons 4 nil)) 5))
(constraint (= (f (cons 0 nil)) 1))
(constraint (= (f nil) 0))
(check-synth)
\end{lstlisting}
In this example, the logic is set to 
datatypes with linear integer arithmetic ${\tt DTLIA}$.
A datatype ${\tt List}$ is then declared,
which encodes lists of integers with two constructors ${\tt nil}$ and ${\tt cons}$.
The input contains a single-function to synthesize $f$
that takes as input a list and returns an integer.
Its grammar contains non-terminal symbols for integers, lists and Booleans,
and includes applications of constructors ${\tt nil}$ and ${\tt cons}$,
selectors ${\tt head}$ and ${\tt tail}$, and
discriminators ${\tt (\_\ is\ nil)}$ and ${\tt (\_\ is\ cons)}$.
A possible correct solution to this synthesis conjecture is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x List)) Int (ite ((_ is nil) x) 0 (+ 1 (head x))))
\end{lstlisting}
In other words, a possible solution for $f$ returns zero whenever its
argument is the empty list ${\tt nil}$, 
and returns one plus the head of its argument otherwise.
\end{example}

\begin{example}[Bit-Vectors with Concatenation and Extraction]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((BV32 (_ BitVec 32)) (BV16 (_ BitVec 16)))
   ((BV32 (_ BitVec 32) (#x00000000 #x00000001 #xFFFFFFFF
                         x
                         (bvand BV32 BV32)
                         (bvor BV32 BV32)
                         (bvnot BV32)
                         (concat BV16 BV16)
                         ))
    (BV16 (_ BitVec 16) (#x0000 #x0001 #xFFFF
                         (bvand BV16 BV16)
                         (bvor BV16 BV16)
                         (bvnot BV16)
                         ((_ extract 31 16) BV32)
                         ((_ extract 15 0) BV32)))))
(constraint (= (f #x0782ECAD) #xECAD0000))
(constraint (= (f #xFFFF008E) #x008E0000))
(constraint (= (f #x00000000) #x00000000))
(check-synth)
\end{lstlisting}
The this example, the logic is set to bit-vectors ${\tt BV}$.
A single function-to-synthesize $f$ is given that takes a
bit-vector of bit-width 32 as input and returns a bit-vector of the same width as output.
Its grammar involves non-terminals whose sorts are bit-vectors of
bit-width 32 and 16.
The semantics of the operators in this example are defined in the SMT-LIB standard.
In particular,
the operator ${\tt concat}$ concatenates its two arguments,
and the indexed operator ${\tt (\_\ extract\ n\ m)}$
returns a bit-vector containing bits $n$ through $m$ of its
argument, where $n \geq m$.
A possible correct solution for $f$ is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x (_ BitVec 32))) (_ BitVec 32) 
   (concat ((_ extract 15 0) x) #x0000))
\end{lstlisting}
In other words, a possible solution for $f$ 
returns the concatenation of bits $15$ to $0$ of its argument
with the bit-vector ${\tt \#x0000}$.
\end{example}

\begin{comment}
\begin{example}[Strings]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic SLIA)
(synth-fun f ((x String)) String
   ((S String) (I Int))
   ((S String ("" x 
               (str.++ S S)
               (str.substr S I I)))
    (I Int    (0 1 (str.len S) (- I I) (+ I I)))))
(constraint (= (f "AB") "A"))
(constraint (= (f "") ""))
(constraint (= (f "AAAA") "AAA"))
(check-synth)
\end{lstlisting}
This example sets the logic to strings with linear arithmetic (${\tt SLIA}$).
A possible correct response from the synthesis solver in this example is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x String)) String (str.substr x 0 (- (str.len x) 1)))
\end{lstlisting}
In other words, the above definition returns 
the substr (via the substring operator ${\tt str.substr}$ starting
at position $0$ and containing (at most) ${\tt (-\ (str.len\ x)\ 1)}$ characters.
Thus, when the argument of $f$ is non-empty, it returns
the result of dropping its last character.
%This is equivalent to dropping the last character from the argument for all inputs.
Moreover, notice this definition for $f$ satisfies the constraint 
${\tt (=\ (f\ }\texttt{""}{\tt)\ \texttt{""})}$ since
substring is interpreted as the empty string when its third argument
is negative.
The semantics for string operators, which includes corner cases
like the one mentioned above,
is given in~\cite{smtlibStrings} and is the semantics assumed by this document.
\end{example}
\end{comment}

\begin{example}[Grammars with Defined Symbols, Forward Declarations and Recursion]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(set-feature :fwd-decls true)
(set-feature :recursion true)
(define-fun x_plus_one ((x Int)) Int (+ x 1))
(synth-fun f ((x Int)) Int
   ((I Int))
   ((I Int (0 1 x (x_plus_one I)))))
(define-fun fx_plus_one ((x Int)) Int (+ (f x) 1))
(synth-fun g ((x Int)) Int
   ((I Int))
   ((I Int (0 1 x (fx_plus_one I)))))
(synth-fun h ((x Int)) Int
   ((I Int) (B Bool))
   ((I Int (0 1 x (- I 1) (+ I I) (h I) (ite B I I)))
    (B Bool ((= I I) (> I I)))))
(declare-var y Int)
(constraint (= (h y) (- (g y) (f y))))
(check-synth)
\end{lstlisting}
This example contains three well-formed $\synthfunkwd$ commands.
The first one for function $f$ contains an application of a macro ${\tt x\_plus\_one}$,
which abbreviates adding one to its argument.
This grammar is allowed in the default SyGuS logic
and in this example.
The grammar for $g$ contains an application of a macro ${\tt fx\_plus\_one}$,
whose expanded form contains a previously declared function-to-synthesize $f$.
This grammar is allowed since the feature $\ffwddeclskwd$ is enabled in this example.
The grammar for $h$ contains a rule that contains an application of $h$ itself.
This grammar is allowed since $\frecursionkwd$ is enabled in this example.
A possible correct response from the synthesis solver in this example is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((x Int)) Int x)
(define-fun g ((x Int)) Int (fx_plus_one x))
(define-fun h ((x Int)) Int 1)
\end{lstlisting}
Notice the above definitions for $f$, $g$, and $h$ are given 
in the order in which they were introduced via $\synthfunkwd$ commands
in the input.
\end{example}

\begin{example}[Strings Programming by Examples (PBE)]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic PBE_SLIA)
(synth-fun f ((fname String) (lname String)) String
    ((ntString String) (ntInt Int))
    ((ntString String (fname lname " "
                       (str.++ ntString ntString)
                       (str.replace ntString ntString ntString)
                       (str.at ntString ntInt)
                       (str.from-int ntInt)
                       (str.substr ntString ntInt ntInt)))
     (ntInt Int (0 1 2
                 (+ ntInt ntInt)
                 (- ntInt ntInt)
                 (str.len ntString)
                 (str.to-int ntString)
                 (str.indexof ntString ntString ntInt)))))
(constraint (= (f "Nancy" "FreeHafer") "Nancy FreeHafer"))
(constraint (= (f "Andrew" "Cencici") "Andrew Cencici"))
(constraint (= (f "Jan" "Kotas") "Jan Kotas"))
(constraint (= (f "Mariya" "Sergienko") "Mariya Sergienko"))
(check-synth)
\end{lstlisting}
In this example, the logic is set to the SyGuS-specific logic
${\tt PBE\_SLIA}$, indicating strings with linear integer arithmetic
where constraints are limited to a conjunction of PBE equalities.
In this example, four constraints are given, each of which meet the
restriction of being a PBE equality.
A possible correct response from the synthesis solver in this example is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun f ((fname String) (lname String)) String
  (str.++ fname (str.++ " " lname)))
\end{lstlisting}
\end{example}

\begin{example}[Invariant Synthesis (Inv)]
Consider the following example:
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic Inv_LIA)
(synth-inv inv-f ((x Int) (y Int)))
(define-fun pre-f ((x Int) (y Int)) Bool 
  (and (>= x 5) (<= x 9) (>= y 1) (<= y 3)))
(define-fun trans-f ((x Int) (y Int) (xp Int) (yp Int)) Bool 
  (and (= xp (+ x 2)) (= yp (+ y 1))))
(define-fun post-f ((x Int) (y Int)) Bool (< y x))
(inv-constraint inv-f pre-f trans-f post-f)
(check-synth)
\end{lstlisting}
In this example, the logic is set to the SyGuS-specific logic
${\tt Inv\_LIA}$, indicating linear integer arithmetic
where constraints are limited to the invariant synthesis problem for
a single invariant-to-synthesize.
Since this example contains only linear integer arithmetic terms,
a single predicate-to-synthesize ${\tt inv-f}$,
and only introduces constraints via a single $\constraintinvkwd$ command,
it meets the restrictions of the logic.
A possible correct response from the synthesis solver in this example is:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun inv-f ((x Int) (y Int)) Bool (>= x y))
\end{lstlisting}
\end{example}

\bibliographystyle{plain}
\bibliography{references}

\newpage
\begin{appendix}

\section{Reserved Words}
\label{apx:reserved}

A \emph{reserved word} is any of the 
literals from \cref{ssec:literals},
or any of the following keywords:
$\checksynthkwd$,
$\constantkwd$,
$\constraintkwd$,
$\dtdeclkwd$,
$\dtsdeclkwd$,
$\sortdeclkwd$,
$\vardeclkwd$,
$\fundefkwd$,
$\sortdefkwd$,
$\existskwd$,
$\forallkwd$,
$\constraintinvkwd$,
$\letkwd$,
$\setfeaturekwd$,
%$\setfeaturesetkwd$,
$\setinfokwd$,
$\setlogickwd$,
%$\setlogicinputkwd$,
%$\setlogicoutputkwd$,
$\setoptkwd$,
$\synthfunkwd$,
$\synthinvkwd$, and
$\varkwd$.


\section{Reference Grammars}
\label{apx:ref-grammars}

In this section, for convenience, we provide the concrete syntax for
grammars that generate exactly the set of terms 
that belong to SMT-LIB logics of interest for a fixed set of free variables.
In particular, this means that each of the following $\synthfunkwd$
commands are equivalent to those in which no grammar is provided.
Note this is not intended to be a complete list of logics.
In particular, we focus on logics that include a single background theory
whose sorts are not parametric.
Each of these grammars are derived
based on the definition of logics and theories
described in the theory and logic declaration documents
available at \url{www.smt-lib.org}.

For each grammar, we omit 
the predicate symbols that are shared by all logics
according to the SMT-LIB standard, that is,
those included in the core theory described in \cref{ssec:smt-logic},
which includes Boolean connectives and equality.
We provide the grammar
for a single function over one of the sorts in the logic,
and assume it has one variable in its argument list
for each non-Boolean sort in the grammar.

\subsection{Integer Arithmetic}

The following grammar for $f$
generates exactly the integer-typed terms in the logic of
linear integer arithmetic (LIA) with one free integer variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LIA)
(synth-fun f ((x Int)) Int
   ((y_term Int) (y_cons Int) (y_pred Bool))
   ((y_term Int  (y_cons
                  (Variable Int)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_cons y_term)
                  (* y_term y_cons)
                  (div y_term y_cons)
                  (mod y_term y_cons)
                  (abs y_term)
                  (ite y_pred y_term y_term)))
    (y_cons Int  ((Constant Int)))
    (y_pred Bool ((= y_term y_term)
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term)
                  (<= y_term y_term)))))
\end{lstlisting}
Above, ${\tt div}$
denotes integer division,
${\tt mod}$ denotes integer modulus and ${\tt abs}$ denotes
the absolute value function.
Positive integer constants and zero are written using the syntax
for numerals $\intconst$. Negative integer constants
are written as the unary negation of a positive integer constant.

The following grammar for $g$ generates exactly the integer-typed terms in the logic of
non-linear integer arithmetic (NIA)
with one free integer variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic NIA)
(synth-fun g ((x Int)) Int
   ((y_term Int) (y_pred Bool))
   ((y_term Int  ((Constant Int) 
                  (Variable Int)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_term y_term)
                  (div y_term y_term)
                  (mod y_term y_term)
                  (abs y_term)
                  (ite y_pred y_term y_term)))
    (y_pred Bool ((= y_term y_term)
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term)
                  (<= y_term y_term)))))
\end{lstlisting}

\subsection{Real Arithmetic}

The following grammar for $f$
generates exactly the real-typed terms in the logic of
linear real arithmetic (LRA)
with one free real variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic LRA)
(synth-fun f ((x Real)) Real
   ((y_term Real) (y_cons Real) (y_pred Bool))
   ((y_term Real (y_cons 
                  (Variable Real) 
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_cons y_term)
                  (* y_term y_cons)
                  (ite y_pred y_term y_term)))
    (y_cons Real ((Constant Real)))
    (y_pred Bool ((= y_term y_term)
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term)
                  (<= y_term y_term)))))
\end{lstlisting}
Notice that positive real constants and zero can either be written 
as decimal values using the syntax $\realconst$
or as rationals, e.g. the division of two numerals
${\tt (/\ m\ n)}$ where $n$ is not zero.
Negative reals are written either as the unary negation of decimal value 
or a rational of the form ${\tt (/\ (-\ m)\ n)}$ for numerals $m$ and $n$
where $n$ is not zero.

The grammar for $g$
generates exactly the real-typed terms in the logic of
non-linear real arithmetic (NRA)
with one free real variable ${\tt x}$.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic NRA)
(synth-fun g ((x Real)) Real
   ((y_term Real) (y_pred Bool))
   ((y_term Real ((Constant Real) 
                  (Variable Real)
                  (- y_term)
                  (+ y_term y_term)
                  (- y_term y_term)
                  (* y_term y_term)
                  (/ y_term y_term)
                  (ite y_pred y_term y_term)))
    (y_pred Bool ((= y_term y_term)
                  (> y_term y_term)
                  (>= y_term y_term)
                  (< y_term y_term)
                  (<= y_term y_term)))))
\end{lstlisting}

\subsection{Fixed-Width Bit-Vectors}

The signature of bit-vectors includes an indexed sort
${\tt BitVec}$, which is indexed by an integer constant that denotes
its bit-width. We show a grammar below for one particular
choice of this bit-width, $32$.
We omit indexed bit-vector operators
such as extraction function ${\tt (\_\ extract\ n\ m)}$, 
the concatenation function ${\tt concat}$,
since these operators are polymorphic.
For brevity,
we also omit the \emph{extended} operators of this theory
as denoted by SMT-LIB,
which includes functions like
bit-vector subtraction ${\tt bvsub}$,
xor ${\tt bvxor}$,
signed division ${\tt bvsdiv}$,
and predicates like
unsigned-greater-than-or-equal ${\tt bvuge}$
and signed-less-than ${\tt bvslt}$.
These extended operators can be seen as syntactic sugar for the
operators in the grammar below.
Example inputs that involve 
some of the omitted operators are given in \cref{sec:examples}.

% ajr: full grammar 
\begin{comment}
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((y_term (_ BitVec 32)) (y_pred Bool))
   ((y_term (_ BitVec 32) ((Constant (_ BitVec 32))
                           (Variable (_ BitVec 32))
                           (bvnot y_term)
                           (bvand y_term y_term)
                           (bvor y_term y_term)
                           (bvneg y_term)
                           (bvadd y_term y_term)
                           (bvmul y_term y_term)
                           (bvudiv y_term y_term)
                           (bvurem y_term y_term)
                           (bvshl y_term y_term)
                           (bvlshr y_term y_term)
                           (bvnand y_term y_term)
                           (bvnor y_term y_term)
                           (bvxor y_term y_term)
                           (bvxnor y_term y_term)
                           (bvsub y_term y_term)
                           (bvsdiv y_term y_term)
                           (bvsrem y_term y_term)
                           (bvsmod y_term y_term)
                           (bvashr y_term y_term)
                           (ite y_pred y_term y_term)))
    (y_pred Bool (...
                  (bvult y_term y_term)
                  (bvule y_term y_term)
                  (bvugt y_term y_term)
                  (bvuge y_term y_term)
                  (bvslt y_term y_term)
                  (bvsle y_term y_term)
                  (bvsgt y_term y_term)
                  (bvsge y_term y_term))))))
\end{lstlisting}
\end{comment}
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic BV)
(synth-fun f ((x (_ BitVec 32))) (_ BitVec 32)
   ((y_term (_ BitVec 32)) (y_pred Bool))
   ((y_term (_ BitVec 32) ((Constant (_ BitVec 32))
                           (Variable (_ BitVec 32))
                           (bvnot y_term)
                           (bvand y_term y_term)
                           (bvor y_term y_term)
                           (bvneg y_term)
                           (bvadd y_term y_term)
                           (bvmul y_term y_term)
                           (bvudiv y_term y_term)
                           (bvurem y_term y_term)
                           (bvshl y_term y_term)
                           (bvlshr y_term y_term)
                           (ite y_pred y_term y_term)))
    (y_pred Bool ((bvult y_term y_term))))))
\end{lstlisting}
Bit-vector constants may be specified
using either the hexadecimal format $\hexconst$
or the binary format $\binaryconst$.


\subsection{Strings}

Notice that there is no
officially adopted SMT-LIB standard for strings at the time
this document was written.
Thus, we adopt (a subset of) the proposed standard~\cite{smtlibStrings}
as of the time of the 2019 edition of the SyGuS competition.
Here, we omit discussion of regular expressions and characters.
\begin{lstlisting}[basicstyle={\ttfamily}]
(set-logic S)
(synth-fun f ((xs String) (xi Int)) String
   ((y_term_str String) (y_term_int Int) (y_pred Bool))
   ((y_term_str String ((Constant String)
                        (Variable String)
                        (str.++ y_term_str y_term_str)
                        (str.at y_term_str y_term_str)
                        (str.substr y_term_str y_term_int y_term_int)
                        (str.indexof y_term_str y_term_str y_term_int)
                        (str.replace y_term_str y_term_str y_term_str)
                        (str.from-int y_term_int)
                        (ite y_pred y_term_str y_term_str)))
    (y_term_int Int ((Variable Int)
                     (str.len y_term_str)
                     (str.to-int y_term_str)
                     (ite y_pred y_term_int y_term_int)))
    (y_pred Bool ((str.contains y_term_str y_term_str)
                  (str.prefixof y_term_str y_term_str)
                  (str.suffixof y_term_str y_term_str)
                  (str.< y_term_str y_term_str)
                  (str.<= y_term_str y_term_str)))))
\end{lstlisting}
% ===== RE
%str.to-re
%str.from-re
%re.none
%re.all
%re.allchar
%re.++
%re.union
%re.inter
%re.*
%str.<=
%re.+
%re.opt
%re.range
%re.^
%re.loop
% ===== characters
%str.char
%str.is-digit
%char.code
%char.from-int
String constants may be specified by text delimited by double quotes
based on the syntax $\stringconst$ described in \cref{ssec:literals}.

Notice that since the logic specified above is ${\tt S}$.
The signature of this logic includes 
some functions involving the integer sort like
${\tt str.len}$.
However, the above logic does not permit inputs containing
integer constants or the standard symbols of arithmetic like 
${\tt +}, {\tt -}$, ${\tt >=}$ and so on, since the logic ${\tt S}$
does not include the theory of integer arithmetic.
Thus in pratice, 
the string theory is frequently combined with the theory of integers
in the logic ${\tt SLIA}$, i.e. strings with linear integer arithmetic.




\section{Language Features of SMT-LIB not Covered}

For the purpose of self-containment,
many of the essential language features of SMT-LIB version 2.6
are redefined in this document.
However, other less essential ones are omitted.
%We do not explicitly forbid the language features of SMT-LIB .
We briefly mention other language features not mentioned in
this document.
We do not require solvers to support these features.
However, we recommend that if solvers support any of the features below,
they use SMT-LIB compliant syntax, as described briefly below.
%\rem{Recommended that if using these, then they are used in this way}

\paragraph{Parametric Datatype Definitions}
We do not cover the concrete syntax or semantics of parametric datatypes (that
is, datatypes whose arity is non-zero) in this document.
An example of a datatype definition for a parametric list is given below.
\begin{lstlisting}[basicstyle={\ttfamily}]
(declare-datatypes ((List 1)) (
  (par (T) ((nil) (cons (head T) (tail (List T)))))))
\end{lstlisting}
Above, the datatype ${\tt List}$ 
is given in the predeclaration with the numeral ${\tt 1}$, indicating
its arity is one.
The datatype definition that follows includes quantification on a type
parameter ${\tt T}$, where this quantification is specified using the 
${\tt par}$ keyword. Within the body of this quantification,
a usual constructor listing is given, where the type parameter ${\tt T}$
may occur free. The constructors of this datatype are ${\tt nil}$
and ${\tt cons}$.

\paragraph{Qualified Identifiers}
In SMT-LIB version 2.6,
identifiers that comprise terms
may be \emph{qualified} with a type-cast, using the keyword $\askwd$.
Type casts are required for symbols whose type is ambiguous,
such as parametric datatype constructors, e.g. the nil constructor
for a parametric list
For the parametric datatype above, 
${\tt (as\ nil\ (List\ Int))}$ and ${\tt (as\ nil\ (List\ Real))}$ 
denote the type constructors
for the empty list of integers and reals respectively.

\paragraph{Match Terms}
The SMT-LIB version 2.6 includes a ${\tt match}$ term
that case splits on the constructors of datatype terms.
For example,
the match term:
\begin{lstlisting}[basicstyle={\ttfamily}]
(match x ((nil (- 1)) ((cons h t) h)))
\end{lstlisting}
returns negative one if the list $x$ is empty,
or the first element of $x$ (its head) if it is non-empty.

\paragraph{Recursive Functions}
The SMT-LIB version 2.6 includes a command $\recfundefkwd$
for defining symbols that involve recursion.\footnote{
Recall that recursive definitions are prohibited from macro definitions in the command
$\fundefkwd$.
}
An example, which computes the length of a (non-parametric) list 
is given below.
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun-rec len ((x List)) Int 
  (match x ((nil 0) ((cons h t) (+ 1 (len t))))))
\end{lstlisting}
Functions may be defined to be mutually recursive by declaring
them in a single block using the $\recfunsdefkwd$ command.
An example, which defines two predicates ${\tt isEven}$ and ${\tt isOdd}$
for determining whether a positive integer is even and odd respectively,
is given in the following.
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-funs-rec (
  (isEven ((x Int)) Bool)
  (isOdd ((x Int)) Bool)
)(
  (ite (= x 0) true (isOdd (- x 1)))
  (ite (= x 0) false (isEven (- x 1)))
))
\end{lstlisting}
Notice that recursive function definitions are not required to be terminating
(the above functions do not terminate for negative integers).
They are not even required to correspond to consistent definitions, for instance:
\begin{lstlisting}[basicstyle={\ttfamily}]
(define-fun-rec inconsistent ((x List)) Int 
  (+ (inconsistent x) 1))
\end{lstlisting}
The semantics of recursive functions is given in 
the SMT-LIB version 2.6 standard~\cite{BarFT-RR-17}.
Each recursive function can be seen as a universally quantified constraint
that asserts that each set of values in the domain of the function
is equal to its body.
%An example, which computes the number of nodes in a tree with 
%an aribtrary number of children, is given below.
%\begin{lstlisting}[basicstyle={\ttfamily}]
%(declare-datatypes ((Tree 0) (CList 0)) (
%  ((leaf) (node (children CList)))
%  ((nil) (cons (head Tree) (tail List)))
%))
%\end{lstlisting}

%The semantics of recursive functions in SyGuS inputs
%is planned to be incorporated in later revisions of this document.

\paragraph{Attribute Annotations}
In SMT-LIB,
terms $t$ may be annotated with \emph{attributes}.
The purpose of an attribute is to mark a term with a set of special properties, 
which may influence the expected result of later commands.
Attributes are specified using the
syntax $\paren{!\mbox{ }t\mbox{ }\kstar{A}}$
where $t$ is a term and $A$ is an attribute.
The syntax for attributes (not given here) is similar to the one
for specifying options and features in this document.
The term above is semantically equivalent to $t$ itself.
Several attributes are standardized by the SMT-LIB standard, while
others may be user-defined.

\paragraph{Additional Logics and Theories}
Several standard logics and theories are omitted from discussion in this document.
This includes the (mixed) theory of integers and reals,
the theory of floating points,
the integer and real difference logic,
and their combinations.
More details on the catalog of logics and theories in the SMT-LIB standard
is available at \url{www.smt-lib.org}.

\end{appendix}


\end{document}
