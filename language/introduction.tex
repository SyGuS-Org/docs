\section{Introduction}%
\label{sec:Introduction}

We present a language to specify instances of the syntax-guided synthesis
(SyGuS) problem. An instance of a SyGuS problem specifies:

\begin{enumerate}
\item
  The vocabularies, theories and the base types that are used to specify
  (a) semantic constraints on the function to be synthesized, and (b) the
  definition of the function to be synthesized itself. We refer to these as
  the \emph{input} and \emph{output} logics respectively.
\item
  A finite set of typed functions $f_1, f_2, \ldots, f_n$ that are to be synthesized.
\item
  The syntactic constraints on each function $f_i, i \in [1,n]$ to be
  synthesized. The syntactic constraints are specified using context-free
  grammars $G_i$ which describe the syntactic structure of candidate
  solution for each of these functions.
  The grammar may only involve function
  symbols and sorts from the specified output logic.
\item
  The semantic constraints and assumptions that describe the behavior of the functions to
  be synthesized. Constraints are given as quantifier-free formulas $\varphi$ 
  and assumptions are given as quantifier-free formulas $\alpha$
  in the input logic, and may refer to the functions-to-synthesize as well as 
  universally quantified variables
  $v_1, v_2, \ldots, v_m$. 
 
\end{enumerate}
The objective then is to find definitions $e_i$ (in the form of
expression bodies) for each function $f_i$ such that (a) the expression
body belongs to the grammar $G_i$ that is used to syntactically constrain
solutions for $f_i$, and 
(b) the constraint 
$\forall v_1, v_2, \ldots,
v_m. \alpha \implies \varphi$ is valid in the background theory
under the assumption that functions $f_1, \ldots, f_n$
are interpreted as functions returning $e_1, \ldots, e_n$.
%\varphi(f_1, f_2, \ldots, f_n, v_1, v_2, \ldots, v_m)[f_i \mathtt{:=}
%  e_i, \ldots, f_n \mathtt{:=} e_n] $ 
Note that each $e_i$ is
an expression containing
a fixed set of free variables which
represent the argument list of the function $f_i$.
%[Do we want to be
%  more precise here and talk about synthesizing lambdas and talk about beta
%  reduction]?
% ajr: its a bit tricky since we allow recursion, best to keep it imprecise for now.
%[TODO: Introduce an example from the old document here? Or do we wait until
%  the Examples section later to talk about examples]
